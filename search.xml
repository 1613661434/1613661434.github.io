<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Doxygen 使用教学</title>
    <url>/2025/12/30/Doxygen%20%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<h1>Doxygen 入门指南：从注释到自动文档</h1>
<p>Doxygen 是一款用于生成代码文档的工具，支持 C、C++、Python 等多种语言，尤其适合 C/C++ 项目。本文将介绍如何使用 Doxygen 规范注释并生成 API 文档。</p>
<h2 id="一、安装-Doxygen">一、安装 Doxygen</h2>
<h3 id="1-Windows">1. Windows</h3>
<ul>
<li>下载安装包：<a href="https://www.doxygen.nl/download.html">Doxygen 官网</a>（选择 <code>doxygen-&lt;version&gt;.setup.exe</code>）</li>
<li>安装时勾选 <code>doxywizard</code>（图形化配置工具，推荐新手使用）</li>
</ul>
<h3 id="2-Linux">2. Linux</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install doxygen graphviz  <span class="comment"># graphviz 用于生成图表</span></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line"><span class="built_in">sudo</span> yum install doxygen graphviz</span><br></pre></td></tr></table></figure>
<h3 id="3-macOS">3. macOS</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install doxygen graphviz</span><br></pre></td></tr></table></figure>
<h2 id="二、基本注释规则">二、基本注释规则</h2>
<p>Doxygen 通过识别特定格式的注释生成文档，核心是 <strong><code>/** ... */</code></strong> 风格的注释块，配合标签（<code>@tag</code>）描述代码信息。</p>
<h3 id="1-函数-方法注释">1. 函数 / 方法注释</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算两个整数的和</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 支持正数、负数和零的加法运算，返回结果不会溢出（假设输入在 int 范围内）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a 第一个加数</span></span><br><span class="line"><span class="comment"> * @param b 第二个加数</span></span><br><span class="line"><span class="comment"> * @return 两数之和（int 类型）</span></span><br><span class="line"><span class="comment"> * @note 若输入超出 int 范围，可能导致未定义行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-类-结构体注释">2. 类 / 结构体注释</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 表示二维坐标的结构体</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 存储 x 和 y 坐标，提供基础的坐标运算方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">///&lt; x 坐标（成员变量注释用 ///&lt;）</span></span><br><span class="line">    <span class="type">int</span> y;  <span class="comment">///&lt; y 坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 初始化坐标</span></span><br><span class="line"><span class="comment">     * @param x_ x 坐标值</span></span><br><span class="line"><span class="comment">     * @param y_ y 坐标值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x_, <span class="type">int</span> y_) : <span class="built_in">x</span>(x_), <span class="built_in">y</span>(y_) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-文件头部注释">3. 文件头部注释</h3>
<p>每个 <code>.h</code> 或 <code>.cpp</code> 文件建议添加头部注释，说明文件功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file math_utils.h</span></span><br><span class="line"><span class="comment"> * @brief 数学工具函数集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 包含加法、减法、乘法等基础运算，以及向量、矩阵操作</span></span><br><span class="line"><span class="comment"> * @author 你的名字</span></span><br><span class="line"><span class="comment"> * @date 2024-05-01</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="三、常用标签速查表">三、常用标签速查表</h2>
<table>
<thead>
<tr>
<th>标签</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@brief</code></td>
<td>简短描述（一句话功能说明）</td>
<td><code>@brief 计算绝对值</code></td>
</tr>
<tr>
<td><code>@param</code></td>
<td>描述函数参数</td>
<td><code>@param num 待计算的数字</code></td>
</tr>
<tr>
<td><code>@return</code></td>
<td>描述返回值</td>
<td><code>@return 非负结果</code></td>
</tr>
<tr>
<td><code>@note</code></td>
<td>补充说明（注意事项）</td>
<td><code>@note 输入不能为nullptr</code></td>
</tr>
<tr>
<td><code>@warning</code></td>
<td>警告信息（危险操作）</td>
<td><code>@warning 此函数会修改原始数组</code></td>
</tr>
<tr>
<td><code>@file</code></td>
<td>标记文件注释</td>
<td><code>@file string_utils.h</code></td>
</tr>
<tr>
<td><code>@author</code></td>
<td>作者信息</td>
<td><code>@author 张三 &lt;zhangsan@example.com&gt;</code></td>
</tr>
<tr>
<td><code>@date</code></td>
<td>日期</td>
<td><code>@date 2024-05-01</code></td>
</tr>
<tr>
<td><code>@see</code></td>
<td>关联内容（参考其他函数 / 类）</td>
<td><code>@see add()</code></td>
</tr>
</tbody>
</table>
<p><img src="/2025/12/30/Doxygen%20%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/Snipaste_2025-08-14_11-49-39.png" alt="标签"></p>
<h2 id="四、生成文档步骤">四、生成文档步骤</h2>
<h3 id="方法-1：使用-doxywizard（图形化工具）">方法 1：使用 doxywizard（图形化工具）</h3>
<ol>
<li>打开 <code>doxywizard</code>（Windows 可在开始菜单找到，Linux/macOS 终端输入 <code>doxywizard</code>）</li>
<li>Step 1: 配置输入输出
<ul>
<li><code>Working directory</code>：选择项目根目录</li>
<li><code>Input</code>：添加代码目录（如 <code>./src</code>）</li>
<li><code>Output directory</code>：设置文档输出路径（如 <code>./docs</code>）</li>
</ul>
</li>
<li>Step 2: 选择输出格式
<ul>
<li>在 <code>Output</code> 标签页勾选 <code>HTML</code>（必选）和 <code>LaTeX</code>（如需 PDF）</li>
</ul>
</li>
<li>Step 3: 生成文档
<ul>
<li>点击 <code>Run doxygen</code>，等待生成完成</li>
<li>打开 <code>./docs/html/index.html</code> 查看文档</li>
</ul>
</li>
</ol>
<h3 id="方法-2：使用命令行（推荐熟练后使用）">方法 2：使用命令行（推荐熟练后使用）</h3>
<ol>
<li>
<p>在项目根目录创建配置文件 <code>Doxyfile</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">doxygen -g Doxyfile  <span class="comment"># 生成默认配置</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编辑<code>Doxyfile</code>关键配置（可选，默认也可生成文档）：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">PROJECT_NAME</span>           = <span class="string">&quot;OL库&quot;</span>  <span class="comment"># 项目名称</span></span><br><span class="line"><span class="attr">INPUT</span>                  = ./src   <span class="comment"># 代码目录</span></span><br><span class="line"><span class="attr">OUTPUT_DIRECTORY</span>       = ./docs  <span class="comment"># 文档输出目录</span></span><br><span class="line"><span class="attr">RECURSIVE</span>              = <span class="literal">YES</span>     <span class="comment"># 递归处理子目录</span></span><br><span class="line"><span class="attr">GENERATE_HTML</span>          = <span class="literal">YES</span>     <span class="comment"># 生成HTML文档</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">doxygen Doxyfile  <span class="comment"># 执行配置文件</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="五、高级技巧">五、高级技巧</h2>
<ol>
<li>
<p><strong>生成调用关系图</strong><br>
在 <code>Doxyfile</code> 中开启：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">HAVE_DOT</span>               = <span class="literal">YES</span></span><br><span class="line"><span class="attr">CALL_GRAPH</span>             = <span class="literal">YES</span></span><br><span class="line"><span class="attr">CALLER_GRAPH</span>           = <span class="literal">YES</span></span><br></pre></td></tr></table></figure>
<p>需提前安装 <code>graphviz</code>（见步骤一）。</p>
</li>
<li>
<p><strong>忽略不需要的代码</strong><br>
用 <code>/// @cond</code> 和 <code>/// @endcond</code> 包裹无需生成文档的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @cond</span></span><br><span class="line"><span class="comment">// 内部辅助函数，不对外暴露</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">helper</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/// @endcond</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>集成到 CMake 构建流程</strong><br>
在 <code>CMakeLists.txt</code> 中添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Doxygen)</span><br><span class="line"><span class="keyword">if</span>(DOXYGEN_FOUND)</span><br><span class="line">    <span class="keyword">add_custom_target</span>(docs</span><br><span class="line">        <span class="keyword">COMMAND</span> doxygen Doxyfile</span><br><span class="line">        WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span></span><br><span class="line">        COMMENT <span class="string">&quot;生成API文档&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>之后可通过 <code>make docs</code>（Linux）或 <code>cmake --build . --target docs</code> 生成文档。</p>
</li>
</ol>
<h2 id="六、常见问题">六、常见问题</h2>
<ul>
<li><strong>注释不生效？</strong><br>
确保注释块以 <code>/**</code> 开头（不是 <code>/*</code> 或 <code>//</code>），且标签拼写正确（区分大小写）。</li>
<li><strong>中文乱码？</strong><br>
在 <code>Doxyfile</code> 中设置 <code>DOXYFILE_ENCODING = UTF-8</code> 和 <code>OUTPUT_LANGUAGE = Chinese</code>。</li>
<li><strong>文档缺少函数？</strong><br>
检查函数是否在 <code>.h</code> 头文件中声明（Doxygen 通常优先解析头文件）。</li>
</ul>
]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>Doxygen</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII码表</title>
    <url>/2025/12/19/ASCII%E7%A0%81%E8%A1%A8/</url>
    <content><![CDATA[<h1>ASCII码表</h1>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符/缩写</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>00</td>
<td>NUL (NULL)</td>
<td>空字符</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>01</td>
<td>SOH (Start Of Headling)</td>
<td>标题开始</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>02</td>
<td>STX (Start Of Text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>03</td>
<td>ETX (End Of Text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>00000100</td>
<td>4</td>
<td>04</td>
<td>EOT (End Of Transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>00000101</td>
<td>5</td>
<td>05</td>
<td>ENQ (Enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>00000110</td>
<td>6</td>
<td>06</td>
<td>ACK (Acknowledge)</td>
<td>回应/响应/收到通知</td>
</tr>
<tr>
<td>00000111</td>
<td>7</td>
<td>07</td>
<td>BEL (Bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>00001000</td>
<td>8</td>
<td>08</td>
<td>BS (Backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>00001001</td>
<td>9</td>
<td>09</td>
<td>HT (Horizontal Tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>00001010</td>
<td>10</td>
<td>0A</td>
<td>LF/NL (Line Feed/New Line)</td>
<td>换行键</td>
</tr>
<tr>
<td>00001011</td>
<td>11</td>
<td>0B</td>
<td>VT (Vertical Tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>00001100</td>
<td>12</td>
<td>0C</td>
<td>FF/NP (Form Feed/New Page)</td>
<td>换页键</td>
</tr>
<tr>
<td>00001101</td>
<td>13</td>
<td>0D</td>
<td>CR (Carriage Return)</td>
<td>回车键</td>
</tr>
<tr>
<td>00001110</td>
<td>14</td>
<td>0E</td>
<td>SO (Shift Out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>0F</td>
<td>SI (Shift In)</td>
<td>启用切换</td>
</tr>
<tr>
<td>00010000</td>
<td>16</td>
<td>10</td>
<td>DLE (Data Link Escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>00010001</td>
<td>17</td>
<td>11</td>
<td>DC1/XON (Device Control 1/Transmission On)</td>
<td>设备控制1/传输开始</td>
</tr>
<tr>
<td>00010010</td>
<td>18</td>
<td>12</td>
<td>DC2 (Device Control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>00010011</td>
<td>19</td>
<td>13</td>
<td>DC3/XOFF (Device Control 3/Transmission Off)</td>
<td>设备控制3/传输中断</td>
</tr>
<tr>
<td>00010100</td>
<td>20</td>
<td>14</td>
<td>DC4 (Device Control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>00010101</td>
<td>21</td>
<td>15</td>
<td>NAK (Negative Acknowledge)</td>
<td>无响应/非正常响应/拒绝接收</td>
</tr>
<tr>
<td>00010110</td>
<td>22</td>
<td>16</td>
<td>SYN (Synchronous Idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>00010111</td>
<td>23</td>
<td>17</td>
<td>ETB (End of Transmission Block)</td>
<td>传输块结束/块传输终止</td>
</tr>
<tr>
<td>00011000</td>
<td>24</td>
<td>18</td>
<td>CAN (Cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>00011001</td>
<td>25</td>
<td>19</td>
<td>EM (End of Medium)</td>
<td>已到介质末端/介质存储已满/介质中断</td>
</tr>
<tr>
<td>00011010</td>
<td>26</td>
<td>1A</td>
<td>SUB (Substitute)</td>
<td>替补/替换</td>
</tr>
<tr>
<td>00011011</td>
<td>27</td>
<td>1B</td>
<td>ESC (Escape)</td>
<td>逃离/取消</td>
</tr>
<tr>
<td>00011100</td>
<td>28</td>
<td>1C</td>
<td>FS (File Separator)</td>
<td>文件分割符</td>
</tr>
<tr>
<td>00011101</td>
<td>29</td>
<td>1D</td>
<td>GS (Group Separator)</td>
<td>组分隔符/分组符</td>
</tr>
<tr>
<td>00011110</td>
<td>30</td>
<td>1E</td>
<td>RS (Record Separator)</td>
<td>记录分离符</td>
</tr>
<tr>
<td>00011111</td>
<td>31</td>
<td>1F</td>
<td>US (Unit Separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>00100000</td>
<td>32</td>
<td>20</td>
<td>(Space)</td>
<td>空格</td>
</tr>
<tr>
<td>00100001</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td></td>
</tr>
<tr>
<td>00100010</td>
<td>34</td>
<td>22</td>
<td>&quot;</td>
<td></td>
</tr>
<tr>
<td>00100011</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td></td>
</tr>
<tr>
<td>00100100</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td></td>
</tr>
<tr>
<td>00100101</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td></td>
</tr>
<tr>
<td>00100110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td></td>
</tr>
<tr>
<td>00100111</td>
<td>39</td>
<td>27</td>
<td>’</td>
<td></td>
</tr>
<tr>
<td>00101000</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td></td>
</tr>
<tr>
<td>00101001</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td></td>
</tr>
<tr>
<td>00101010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>00101011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>00101100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td></td>
</tr>
<tr>
<td>00101101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>00101110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td></td>
</tr>
<tr>
<td>00101111</td>
<td>47</td>
<td>2F</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>00110000</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>00110001</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>00110010</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>00110011</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>00110100</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>00110101</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>00110110</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>00110111</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>00111000</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>00111001</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>00111010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>00111011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td></td>
</tr>
<tr>
<td>00111100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>00111101</td>
<td>61</td>
<td>3D</td>
<td>=</td>
<td></td>
</tr>
<tr>
<td>00111110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>00111111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>01000000</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td></td>
</tr>
<tr>
<td>01000001</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td></td>
</tr>
<tr>
<td>01000010</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>01000011</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>01000100</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>01000101</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td></td>
</tr>
<tr>
<td>01000110</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>01000111</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>01001000</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td></td>
</tr>
<tr>
<td>01001001</td>
<td>73</td>
<td>49</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>01001010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>01001011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td></td>
</tr>
<tr>
<td>01001100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td></td>
</tr>
<tr>
<td>01001101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td></td>
</tr>
<tr>
<td>01001110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>01001111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>01010000</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td></td>
</tr>
<tr>
<td>01010001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td></td>
</tr>
<tr>
<td>01010010</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td></td>
</tr>
<tr>
<td>01010011</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>01010100</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>01010101</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td></td>
</tr>
<tr>
<td>01010110</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>01010111</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td>01011000</td>
<td>88</td>
<td>58</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>01011001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>01011010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>01011011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td></td>
</tr>
<tr>
<td>01011100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>01011101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td></td>
</tr>
<tr>
<td>01011110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td></td>
</tr>
<tr>
<td>01011111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td></td>
</tr>
<tr>
<td>01100000</td>
<td>96</td>
<td>60</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>01100001</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td></td>
</tr>
<tr>
<td>01100010</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>01100011</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td></td>
</tr>
<tr>
<td>01100100</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td></td>
</tr>
<tr>
<td>01100101</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td></td>
</tr>
<tr>
<td>01100110</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td></td>
</tr>
<tr>
<td>01100111</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td></td>
</tr>
<tr>
<td>01101000</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td></td>
</tr>
<tr>
<td>01101001</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td></td>
</tr>
<tr>
<td>01101010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td></td>
</tr>
<tr>
<td>01101011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td></td>
</tr>
<tr>
<td>01101100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td></td>
</tr>
<tr>
<td>01101101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td></td>
</tr>
<tr>
<td>01101110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td>01101111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td></td>
</tr>
<tr>
<td>01110000</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td></td>
</tr>
<tr>
<td>01110001</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td></td>
</tr>
<tr>
<td>01110010</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td></td>
</tr>
<tr>
<td>01110011</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td></td>
</tr>
<tr>
<td>01110100</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td></td>
</tr>
<tr>
<td>01110101</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td></td>
</tr>
<tr>
<td>01110110</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td></td>
</tr>
<tr>
<td>01110111</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td></td>
</tr>
<tr>
<td>01111000</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>01111001</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>01111010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td></td>
</tr>
<tr>
<td>01111011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td></td>
</tr>
<tr>
<td>01111100</td>
<td>124</td>
<td>7C</td>
<td></td>
<td></td>
</tr>
<tr>
<td>01111101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td></td>
</tr>
<tr>
<td>01111110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>01111111</td>
<td>127</td>
<td>7F</td>
<td>DEL (Delete)</td>
<td>删除</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>ASCII码</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake Memo</title>
    <url>/2025/12/07/CMake%20Memo/</url>
    <content><![CDATA[<h1>CMake Memo</h1>
<blockquote>
<p>作者：OL</p>
<p>本文档是参考了以下作者</p>
<ul>
<li><a href="https://space.bilibili.com/80353385">编程Cat加加</a></li>
<li><a href="https://subingwen.cn/">爱编程的大丙</a></li>
</ul>
<p>相关链接：</p>
<ul>
<li>编程Cat加加的CMake教程视频：<a href="https://www.bilibili.com/video/BV1rqPYehEsW">https://www.bilibili.com/video/BV1rqPYehEsW</a></li>
<li>爱编程的大丙的CMake教程文章：<a href="https://subingwen.cn/cmake/CMake-primer/">https://subingwen.cn/cmake/CMake-primer/</a></li>
<li>CMake 教程 | 菜鸟教程：<a href="https://www.runoob.com/cmake/cmake-tutorial.html">https://www.runoob.com/cmake/cmake-tutorial.html</a></li>
<li>CMake 官网：<a href="https://cmake.org/">https://cmake.org/</a></li>
<li>CMake 官方文档：<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">https://cmake.org/cmake/help/latest/guide/tutorial/index.html</a></li>
<li>CMake 源码：<a href="https://github.com/Kitware/CMake">https://github.com/Kitware/CMake</a></li>
<li>CMake 源码：<a href="https://gitlab.kitware.com/cmake/cmakeku">https://gitlab.kitware.com/cmake/cmakeku</a></li>
</ul>
<p>[]和&lt;&gt;中为可选项</p>
</blockquote>
<h2 id="命令行命令">命令行命令</h2>
<ul>
<li>
<p><code>cmake -G</code></p>
<p>可以查看所有的生成器</p>
<p>默认使用<code>Visual Studio 17 2022</code>，前面带<code>*</code>的就是默认的生成器</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Administrator&gt;cmake <span class="literal">-G</span></span><br><span class="line">CMake Error: No generator specified <span class="keyword">for</span> <span class="literal">-G</span></span><br><span class="line"></span><br><span class="line">Generators</span><br><span class="line">* Visual Studio <span class="number">17</span> <span class="number">2022</span>        = Generates Visual Studio <span class="number">2022</span> project files. <span class="comment"># 默认生成器</span></span><br><span class="line">                                 Use <span class="literal">-A</span> option to specify architecture.</span><br><span class="line">  Visual Studio <span class="number">16</span> <span class="number">2019</span>        = Generates Visual Studio <span class="number">2019</span> project files.</span><br><span class="line">                                 Use <span class="literal">-A</span> option to specify architecture.</span><br><span class="line">  Visual Studio <span class="number">15</span> <span class="number">2017</span>        = Generates Visual Studio <span class="number">2017</span> project files.</span><br><span class="line">                                 Use <span class="literal">-A</span> option to specify architecture.</span><br><span class="line">  Visual Studio <span class="number">14</span> <span class="number">2015</span>        = Generates Visual Studio <span class="number">2015</span> project files.</span><br><span class="line">                                 Use <span class="literal">-A</span> option to specify architecture.</span><br><span class="line">  Borland Makefiles            = Generates Borland makefiles.</span><br><span class="line">  NMake Makefiles              = Generates NMake makefiles.</span><br><span class="line">  NMake Makefiles JOM          = Generates JOM makefiles.</span><br><span class="line">  MSYS Makefiles               = Generates MSYS makefiles.</span><br><span class="line">  MinGW Makefiles              = Generates a make file <span class="keyword">for</span> use with</span><br><span class="line">                                 mingw32<span class="literal">-make</span>.</span><br><span class="line">  Green Hills MULTI            = Generates Green Hills MULTI files</span><br><span class="line">                                 (experimental, work<span class="operator">-in</span><span class="literal">-progress</span>).</span><br><span class="line">  Unix Makefiles               = Generates standard UNIX makefiles.</span><br><span class="line">  Ninja                        = Generates build.ninja files.</span><br><span class="line">  Ninja Multi<span class="literal">-Config</span>           = Generates build-&lt;Config&gt;.ninja files.</span><br><span class="line">  Watcom WMake                 = Generates Watcom WMake makefiles.</span><br><span class="line">  CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeBlocks - NMake Makefiles = Generates CodeBlocks project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeBlocks - NMake Makefiles JOM</span><br><span class="line">                               = Generates CodeBlocks project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeBlocks - Ninja           = Generates CodeBlocks project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeLite - MinGW Makefiles   = Generates CodeLite project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeLite - NMake Makefiles   = Generates CodeLite project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeLite - Ninja             = Generates CodeLite project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  CodeLite - Unix Makefiles    = Generates CodeLite project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Eclipse CDT4 - NMake Makefiles</span><br><span class="line">                               = Generates Eclipse CDT <span class="number">4.0</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Eclipse CDT4 - MinGW Makefiles</span><br><span class="line">                               = Generates Eclipse CDT <span class="number">4.0</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Eclipse CDT4 - Ninja         = Generates Eclipse CDT <span class="number">4.0</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT <span class="number">4.0</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Kate - MinGW Makefiles       = Generates Kate project files (deprecated).</span><br><span class="line">  Kate - NMake Makefiles       = Generates Kate project files (deprecated).</span><br><span class="line">  Kate - Ninja                 = Generates Kate project files (deprecated).</span><br><span class="line">  Kate - Ninja Multi<span class="literal">-Config</span>    = Generates Kate project files (deprecated).</span><br><span class="line">  Kate - Unix Makefiles        = Generates Kate project files (deprecated).</span><br><span class="line">  Sublime Text <span class="number">2</span> - MinGW Makefiles</span><br><span class="line">                               = Generates Sublime Text <span class="number">2</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Sublime Text <span class="number">2</span> - NMake Makefiles</span><br><span class="line">                               = Generates Sublime Text <span class="number">2</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Sublime Text <span class="number">2</span> - Ninja       = Generates Sublime Text <span class="number">2</span> project files</span><br><span class="line">                                 (deprecated).</span><br><span class="line">  Sublime Text <span class="number">2</span> - Unix Makefiles</span><br><span class="line">                               = Generates Sublime Text <span class="number">2</span> project files</span><br><span class="line">                                 (deprecated).</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#cmdoption-cmake-S"><code>cmake -S </code></a></p>
<p>指定项目根目录，CMake 将在那里被建造。</p>
</li>
<li>
<p><a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#cmdoption-cmake-B"><code>cmake -B </code></a></p>
<p>指定构建目录，CMake 将输出生成的构建系统，以及当构建系统已经运行。未指定时，默认为当前工作目录。</p>
</li>
<li>
<p><a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#cmdoption-cmake-build"><code>cmake --build</code></a></p>
<p>在指定的构建目录中运行构建系统。这是通用的所有生成器的命令。对于多配置生成器，期望的配置请求可通过以下方式进行：</p>
<p><code>cmake --build &lt;dir&gt; --config &lt;cfg&gt;</code></p>
<p><code>&lt;dir&gt;</code>是生成器的目录</p>
<p><code>&lt;cfg&gt;</code>可以是<code>Release</code>、<code>Debug</code></p>
<p>例如<code>MinGW Makefiles</code>要使用<code>make</code>编译，此命令可以将所有的生成器的命令统一</p>
</li>
<li>
<p><code>cmake -D</code></p>
<p><code>cmake -D</code> 是 CMake 中<strong>运行时手动设置 / 覆盖变量</strong>的核心命令，作用是：在执行 <code>cmake</code> 生成构建文件（Makefile、VS 项目等）时，直接指定 CMake 变量的值，无需修改 <code>CMakeLists.txt</code>。</p>
<p>它的使用场景非常广泛（比如启用测试、切换构建类型、指定路径等）</p>
<p><strong>核心语法:</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake -D&lt;变量名&gt;=&lt;变量值&gt; ..</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>-D</code>：固定前缀，后面紧跟「变量名 = 变量值」（<strong>无空格</strong>，<code>=</code> 前后不能有空格）；</p>
</li>
<li>
<p><code>&lt;变量名&gt;</code>：可以是 CMake 内置变量（如 <code>CMAKE_BUILD_TYPE</code>），也可以是你自定义的选项（如 <code>OL_WITH_TESTS</code>）；</p>
</li>
<li>
<p><code>&lt;变量值&gt;</code>：根据变量类型不同，支持 3 类值（布尔、字符串、路径）；</p>
</li>
<li>
<p><code>..</code>：最后是源文件目录（即 <code>CMakeLists.txt</code> 所在的上级目录，固定写法，除非你的目录结构特殊）。</p>
<p><strong>关键细节：</strong></p>
</li>
<li>
<p>变量名<strong>大小写敏感</strong>（<code>OL_WITH_TESTS</code> ≠ <code>ol_with_tests</code>）；</p>
</li>
<li>
<p>多个 <code>-D</code> 可以叠加（设置多个变量）；</p>
</li>
<li>
<p>变量值如果包含空格或特殊字符，需要用引号包裹（如 <code>-DINSTALL_PATH=&quot;C:/Program Files/ol&quot;</code>）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CMake语法">CMake语法</h2>
<h3 id="cmake-minimum-required-VERSION-major-minor-patch">- <code>cmake_minimum_required(VERSION major.minor[.patch])</code></h3>
<p>CMake要求的最低版本号，通常只需要<strong>主版本号和次版本号</strong></p>
<h3 id="project-项目名-VERSION-版本号-DESCRIPTION-项目描述-LANGUAGES-编程语言">- <code>project(项目名 [VERSION 版本号] [DESCRIPTION &quot;项目描述&quot;] [LANGUAGES 编程语言...])</code></h3>
<p>编程语言默认是C/C++，选择C++的话应该填<strong>CXX</strong></p>
<h3 id="target相关命令">- target相关命令</h3>
<p>可以把target当做编程语言的类和对象看待</p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251125194546681-1764071149278-1.png" alt=""></p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251121193142690-1763724707050-1.png" alt=""></p>
<h4 id="1-创建可执行目标（ADD-EXECUTABLE）">1. 创建可执行目标（ADD_EXECUTABLE）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;<span class="keyword">target</span>&gt; [WIN32] [MACOSX_BUNDLE] &lt;source1&gt; [&lt;source2&gt; ...])</span><br><span class="line"><span class="keyword">add_executable</span>(&lt;<span class="keyword">target</span>&gt; <span class="string">&quot;&quot;</span>) <span class="comment"># 空目标，后续用target_sources补充</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：目标名称（全局唯一）。</li>
<li><code>WIN32</code>：Windows 下创建 GUI 程序（无控制台窗口）。</li>
<li><code>MACOSX_BUNDLE</code>：macOS 下创建应用 bundle 包。</li>
<li><code>&lt;sourceN&gt;</code>：源文件路径列表，可空。</li>
</ul>
<h4 id="2-创建库目标（ADD-LIBRARY）">2. 创建库目标（ADD_LIBRARY）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;<span class="keyword">target</span>&gt; &lt;type&gt; &lt;source1&gt; [&lt;source2&gt; ...])</span><br><span class="line"><span class="keyword">add_library</span>(&lt;<span class="keyword">target</span>&gt; <span class="string">&quot;&quot;</span>) <span class="comment"># 空目标，后续补充源文件</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：库目标名称（全局唯一）。</li>
<li><code>&lt;type&gt;</code>：库类型（必填）：
<ul>
<li><code>STATIC</code>：静态库（.a/.lib）。</li>
<li><code>SHARED</code>：动态库（.so/.dll）。</li>
<li><code>MODULE</code>：模块库（动态加载插件）。</li>
<li><code>OBJECT</code>：对象库（仅编译不归档）。</li>
</ul>
</li>
<li><code>&lt;sourceN&gt;</code>：源文件路径列表，可空。</li>
</ul>
<h4 id="3-设置目标包含目录（TARGET-INCLUDE-DIRECTORIES）">3. 设置目标包含目录（TARGET_INCLUDE_DIRECTORIES）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; &lt;scope&gt; &lt;dir1&gt; [&lt;dir2&gt; ...])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：目标名称。</li>
<li><code>&lt;scope&gt;</code>：作用域（必填）：
<ul>
<li><code>PRIVATE</code>：仅当前目标编译生效。</li>
<li><code>INTERFACE</code>：仅依赖该目标的目标生效。</li>
<li><code>PUBLIC</code>：当前目标 + 依赖目标均生效。</li>
</ul>
</li>
<li><code>&lt;dirN&gt;</code>：头文件搜索目录路径。</li>
</ul>
<h4 id="4-设置预编译宏（TARGET-COMPILE-DEFINITIONS）">4. 设置预编译宏（TARGET_COMPILE_DEFINITIONS）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(&lt;<span class="keyword">target</span>&gt; &lt;scope&gt; &lt;def1&gt; [&lt;def2&gt; ...])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：目标名称。</li>
<li><code>&lt;scope&gt;</code>：作用域（必填）：PRIVATE/INTERFACE/PUBLIC（同上方）。</li>
<li><code>&lt;defN&gt;</code>：预编译宏，格式如 <code>MY_DEF</code> 或 <code>MY_DEF=1</code>。</li>
</ul>
<h4 id="5-设置编译选项（TARGET-COMPILE-OPTIONS）">5. 设置编译选项（TARGET_COMPILE_OPTIONS）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(&lt;<span class="keyword">target</span>&gt; &lt;scope&gt; &lt;opt1&gt; [&lt;opt2&gt; ...])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：目标名称。</li>
<li><code>&lt;scope&gt;</code>：作用域（必填）：PRIVATE/INTERFACE/PUBLIC（同上方）。</li>
<li><code>&lt;optN&gt;</code>：编译选项，如 <code>-Wall</code>（Linux）、<code>/W4</code>（MSVC）。</li>
</ul>
<h4 id="6-链接依赖库-选项（TARGET-LINK-LIBRARIES）">6. 链接依赖库 / 选项（TARGET_LINK_LIBRARIES）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; &lt;scope&gt; &lt;dep1&gt; [&lt;dep2&gt; ...])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：目标名称。</li>
<li><code>&lt;scope&gt;</code>：作用域（必填）：PRIVATE/INTERFACE/PUBLIC（同上方）。</li>
<li><code>&lt;depN&gt;</code>：依赖项，可是：
<ul>
<li>自定义库目标名（如 <code>MyLib</code>）。</li>
<li>系统库名（如 <code>pthread</code>）。</li>
<li>链接选项（需引号包裹，如 <code>-Wl,-rpath=./lib</code>）。</li>
</ul>
</li>
</ul>
<h4 id="7-设置目标属性（SET-TARGET-PROPERTIES）">7. 设置目标属性（SET_TARGET_PROPERTIES）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(&lt;target1&gt; [&lt;target2&gt; ...] PROPERTIES &lt;prop1&gt; &lt;val1&gt; &lt;prop2&gt; &lt;val2&gt; ...)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;targetN&gt;</code>：一个 / 多个目标名称。</li>
<li><code>&lt;propN&gt;</code>：常用属性：
<ul>
<li><code>CXX_STANDARD</code>：C++ 标准（如 17、20）。</li>
<li><code>CXX_STANDARD_REQUIRED</code>：是否强制标准（ON/OFF）。</li>
<li><code>OUTPUT_NAME</code>：目标输出文件名（覆盖默认名）。</li>
<li><code>RUNTIME_OUTPUT_DIRECTORY</code>：可执行 / 动态库输出目录（Windows）。</li>
<li><code>LIBRARY_OUTPUT_DIRECTORY</code>：动态库输出目录（Linux/Mac）。</li>
<li><code>ARCHIVE_OUTPUT_DIRECTORY</code>：静态库输出目录。</li>
</ul>
</li>
<li><code>&lt;valN&gt;</code>：属性对应值。</li>
</ul>
<h4 id="8-补充目标源文件（TARGET-SOURCES）">8. 补充目标源文件（TARGET_SOURCES）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_sources</span>(&lt;<span class="keyword">target</span>&gt; &lt;scope&gt; &lt;source1&gt; [&lt;source2&gt; ...])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;target&gt;</code>：已创建的目标名称。</li>
<li><code>&lt;scope&gt;</code>：作用域（必填）：PRIVATE/INTERFACE/PUBLIC（INTERFACE 仅适用于库）。</li>
<li><code>&lt;sourceN&gt;</code>：需补充的源文件路径列表。</li>
</ul>
<h4 id="9-创建别名目标（ALIAS）">9. 创建别名目标（ALIAS）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;alias&gt; ALIAS &lt;<span class="keyword">target</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>&lt;alias&gt;</code>：别名（规范格式：<code>&lt;命名空间&gt;::&lt;目标名&gt;</code>，如 <code>MyLib::Core</code>）。</li>
<li><code>&lt;target&gt;</code>：已创建的库 / 可执行目标名称。</li>
</ul>
<h3 id="变量">- 变量</h3>
<p><img src="/2025/12/07/CMake%20Memo/image-20251121212323593-1763731407488-1.png" alt=""></p>
<p><strong>CMAKE_开头的变量</strong>是<strong>CMAKE预定义的变量</strong></p>
<p>还有其他的，如：</p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123214601992-1763905563767-13.png" alt=""></p>
<p>变量存储的都是字符串，且用<strong>列表</strong>存储，<code>;</code>是专门用于<strong>列表的分隔符</strong></p>
<ul>
<li>
<p><code>set(varName value... [PARENT_SCOPE])</code> 定义变量</p>
<p>例如 <code>set(myVar hello world)</code>，相当于myVar=hello;world</p>
<p>下列语句与之等价：</p>
<ul>
<li><code>set(myVar hello;world)</code></li>
<li><code>set(myVar &quot;hello;world&quot;)</code></li>
</ul>
<p>如果<strong>不需要将<code>;</code>用于列表的分隔符</strong>，可以用转义字符<code>\;</code>，例如<code>set(myVar &quot;hello\;world&quot;)</code></p>
<p>如果**需要在字符串有空格<code> </code>**可以用双引号<code>&quot;&quot;</code>包裹字符串，例如<code>set(myVar &quot;hello world&quot;)</code></p>
<p>当需要<strong>引用变量</strong>，可以使用<code>$&#123;变量名&#125;</code>，可以出现在<code>&quot;&quot;</code>中，例如<code>$&#123;myVar&#125;</code>，<code>set(pet &quot;$&#123;myVar&#125;&quot;)</code></p>
<p>字符串也可以用<code>[[]]</code>,也可以<code>[=^n[]=^n]</code>(n&gt;=0)，其中<code>=^n</code>表示可以任意<code>=</code>但左右两边必须一样，这种方式不会进行替换，所以可以打印<code>$&#123;&#125;</code></p>
</li>
<li>
<p><code>set(varName)</code>、<code>unset(varName)</code>设置未定义变量，<code>set(varName &quot;&quot;)</code>清空变量的值</p>
</li>
<li>
<p><code>set(ENV&#123;varName&#125; value)</code> 设置环境变量</p>
<p>这种方式只是临时添加环境变量，不会改变系统环境变量</p>
</li>
<li>
<p><code>set(varName value... CACHE type &quot;helpString&quot; [FORCE])</code> 定义缓存变量（Cache Variable）</p>
<p>存放在<code>\build\CMakeCache.txt</code></p>
<ol>
<li>参数<code>type</code>主要用于图形界面的处理，<strong>虽然变量都为字符串，但是图形界面中会将变量分为以下类型：</strong></li>
</ol>
<p><img src="/2025/12/07/CMake%20Memo/image-20251121223113174-1763735476917-1.png" alt=""></p>
<p>BOOL类型值的设置</p>
<ul>
<li>
<p>真：true、yes、Y、1</p>
</li>
<li>
<p>假：false、no、n、0</p>
<p>对于BOOL，也可以使用<code>option(optVar &quot;helpString&quot; [初始值])</code>，相当于没有<code>FORCE</code>的BOOL值，</p>
<p>即<code>set(optVar [初始值] CACHE BOOL helpString)</code></p>
</li>
</ul>
<p>例如下面示例：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(LearnCMake VERSION <span class="number">0.1</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(DEMO_VAR <span class="keyword">off</span> CACHE BOOL <span class="string">&quot;is test&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;DEMO_VAR = $&#123;DEMO_VAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">ON</th>
<th style="text-align:center">OFF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/2025/12/07/CMake%20Memo/image-20251121224016569-1763736018033-3.png" alt=""></td>
<td style="text-align:center"><img src="/2025/12/07/CMake%20Memo/image-20251121224233527-1763736154891-5.png" alt=""></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>
<p>参数<code>&quot;helpString&quot;</code>是说明变量的用途</p>
</li>
<li>
<p>参数<code>FORCE</code>是用于强制刷新变量</p>
<ul>
<li>
<p>无<code>FORCE</code>，则当缓存没有这个变量才写入，有则不会更新</p>
</li>
<li>
<p>有<code>FORCE</code>，则会强制更新缓存中的值</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>普通变量 VS 缓存变量</p>
<ul>
<li>对于同名的普通变量和缓存变量，优先使用普通变量，例子：</li>
</ul>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(myVar <span class="string">&quot;Hello World!&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;My Variable&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(myVar <span class="string">&quot;normal variable&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;myVar=&quot;</span> <span class="variable">$&#123;myVar&#125;</span>)</span><br><span class="line"><span class="keyword">unset</span>(myVar)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;myVar=&quot;</span> <span class="variable">$&#123;myVar&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># myVar=normal variable</span></span><br><span class="line"><span class="comment"># myVar=Hello World!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>推荐的命名规范：<strong>普通变量用驼峰命名，缓存变量用纯大写字母</strong></p>
</li>
<li>
<p>作用域：<strong>普通变量是局部（函数，子目录），缓存变量是全局</strong></p>
</li>
</ul>
</li>
<li>
<p>命令行定义缓存变量</p>
<ul>
<li>
<p><code>cmake -D &quot;varName:type=value&quot;</code> 定义缓存变量</p>
</li>
<li>
<p><code>cmake -U &quot;&quot;</code> 删除缓存变量</p>
<p>例如：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake -D <span class="string">&quot;MY_VAR:STRING=hello world&quot;</span> <span class="comment"># 定义MY_VAR缓存变量</span></span><br><span class="line">cmake -U <span class="string">&quot;MY*&quot;</span> <span class="comment"># 删除所有MY开头的缓存变量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="message">- <code>message()</code></h3>
<p>为用户显示一条消息</p>
<p><code>message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] &quot;message to display&quot; ...)</code></p>
<ul>
<li>(无) ：重要消息</li>
<li>STATUS ：非重要消息</li>
<li>WARNING：CMake 警告, 会继续执行</li>
<li>AUTHOR_WARNING：CMake 警告 (dev), 会继续执行</li>
<li>SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤</li>
<li>FATAL_ERROR：CMake 错误, 终止所有处理过程</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(b hello)</span><br><span class="line"><span class="keyword">set</span>(c &#x27;hello&#x27;)</span><br><span class="line"><span class="keyword">set</span>(d &#x27;hello)</span><br><span class="line"><span class="keyword">set</span>(e [[hello]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;a=&quot;</span> <span class="variable">$&#123;a&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;b=&quot;</span> <span class="variable">$&#123;b&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;c=&quot;</span> <span class="variable">$&#123;c&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;d=&quot;</span> <span class="variable">$&#123;d&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;e=&quot;</span> <span class="variable">$&#123;e&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># -- a=hello</span></span><br><span class="line"><span class="comment"># -- b=hello</span></span><br><span class="line"><span class="comment"># -- c=&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># -- d=&#x27;hello</span></span><br><span class="line"><span class="comment"># -- e=hello</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域block-和endblock">- 作用域<code>block()</code>和<code>endblock()</code></h3>
<p>例子1：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(myVar cat)</span><br><span class="line">block()</span><br><span class="line">	<span class="keyword">set</span>(myVar dog)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;myVar=$&#123;myVar&#125;&quot;</span>)</span><br><span class="line">endblock()</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myVar=$&#123;myVar&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># myVar=dog</span></span><br><span class="line"><span class="comment"># myVar=cat</span></span><br></pre></td></tr></table></figure>
<p>例子2：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(myVar cat)</span><br><span class="line">block() <span class="comment"># 进入局部，相当于拷贝父作用域的变量，值传递</span></span><br><span class="line">	<span class="keyword">set</span>(myVar dog PARENT_SCOPE) <span class="comment"># 使用父作用域的引用，引用传递</span></span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;[block]myVar=$&#123;myVar&#125;&quot;</span>)</span><br><span class="line">endblock()</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;[outer]myVar=$&#123;myVar&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [block]myVar=cat</span></span><br><span class="line"><span class="comment"># [outer]myVar=dog</span></span><br></pre></td></tr></table></figure>
<p>例子3：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(myVar cat)</span><br><span class="line">block(SCOPE_FOR VARIABLES PROPAGATE myVar) <span class="comment"># PROPAGATE 后面的变量都是父作用域的引用 </span></span><br><span class="line">	<span class="keyword">set</span>(myVar dog)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;[block]myVar=$&#123;myVar&#125;&quot;</span>)</span><br><span class="line">endblock()</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;[outer]myVar=$&#123;myVar&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [block]myVar=dog</span></span><br><span class="line"><span class="comment"># [outer]myVar=dog</span></span><br></pre></td></tr></table></figure>
<h3 id="条件判断">- 条件判断</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr)</span><br><span class="line">	<span class="comment"># expr == true</span></span><br><span class="line"><span class="keyword">elseif</span>(expr2)</span><br><span class="line">	<span class="comment"># expr == false &amp;&amp; expr2 == true</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="comment"># otherwise</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>expr:</p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123211243249-1763903566276-1.png" alt=""></p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123211327749.png" alt=""></p>
<p>如果expr为字符串，那么是TRUE常量带引号模式才为真</p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123211450821-1763903693214-3.png" alt=""></p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123211623958-1763903785883-5.png" alt=""></p>
<p>例子：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(v <span class="string">&quot;hello&quot;</span>) <span class="comment"># 变量规则：此时v的值不是FALSE常量，所以为TRUE</span></span><br><span class="line"><span class="keyword">if</span>(v)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;$&#123;v&#125; is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;$&#123;v&#125; if false&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;v&#125;</span>) <span class="comment"># 字符串规则：此时$&#123;v&#125;字符串不是TRUE常量，所以为FALSE</span></span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;&#x27;$&#123;v&#125;&#x27; is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;&#x27;$&#123;v&#125;&#x27; is false&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符">- 逻辑运算符</h3>
<ul>
<li>与：<code>AND</code></li>
<li>或：<code>OR</code></li>
<li>非：<code>NOT</code></li>
</ul>
<h3 id="比较运算符">- 比较运算符</h3>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123214025313-1763905226655-7.png" alt=""></p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123214302686-1763905386222-9.png" alt=""></p>
<p><img src="/2025/12/07/CMake%20Memo/image-20251123214358551-1763905439877-11.png" alt=""></p>
<h3 id="循环语句">- 循环语句</h3>
<ul>
<li>
<p><code>continue()</code>：跳过循环</p>
</li>
<li>
<p><code>break()</code>：退出循环</p>
</li>
</ul>
<ol>
<li>
<p>foreach循环</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">	&lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example1</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Example1:&quot;</span>)</span><br><span class="line"><span class="keyword">foreach</span>(v a b c)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;v=$&#123;v&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example2 使用IN和LISTS关键字</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Example2:&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(list1 <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span>)</span><br><span class="line"><span class="keyword">set</span>(list2 <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(v IN LISTS list1 list2) <span class="comment"># 也可以 foreach(v IN ITEMS $&#123;list1&#125; $&#123;list2&#125;) 注意这里是ITEMS</span></span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;v=$&#123;v&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example3 使用IN和ITEMS关键字 等价于 Example1</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Example3:&quot;</span>)</span><br><span class="line"><span class="keyword">foreach</span>(v IN ITEMS a b c)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;v=$&#123;v&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example4 使用IN和ZIP_LISTS关键字，同时获取不同列表的相同位置</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Example4:&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(list3 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"><span class="keyword">set</span>(list4 <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(v IN ZIP_LISTS list3 list4)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;v=($&#123;v_0&#125;,$&#123;v_1&#125;)&quot;</span>) <span class="comment"># 变量名_数字 来分别获取不同列表的元素</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example5 使用RANGE关键字，设定开始和结尾</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Example5:&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(start <span class="number">1</span>)</span><br><span class="line"><span class="keyword">set</span>(end <span class="number">8</span>)</span><br><span class="line"><span class="keyword">set</span>(step <span class="number">2</span>) <span class="comment"># 可选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(v RANGE <span class="variable">$&#123;start&#125;</span> <span class="variable">$&#123;end&#125;</span> <span class="variable">$&#123;step&#125;</span>) <span class="comment"># step是缺省值，默认是1</span></span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;v=$&#123;v&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>while循环</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">	&lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注释">- 注释</h3>
<ul>
<li><code>#</code>：行注释</li>
<li><code>#[[]]</code>：块注释</li>
</ul>
<h3 id="函数">- 函数</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(function_name args...)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>传参方式：</strong></p>
<ul>
<li>命名参数</li>
</ul>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_function a b) <span class="comment"># a 和 b 是命名参数</span></span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;============= my_function =============&quot;</span>)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;a:$&#123;a&#125;,b:$&#123;b&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_function(hello world) <span class="comment"># 调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">============= my_function =============</span><br><span class="line">a:hello,b:world</span><br></pre></td></tr></table></figure>
<ul>
<li>未命名参数</li>
</ul>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_function2 a b) <span class="comment"># a 和 b 是命名参数</span></span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;============= my_function2 =============&quot;</span>)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;a:$&#123;a&#125;,b:$&#123;b&#125;&quot;</span>)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;ARGC:$&#123;ARGC&#125;&quot;</span>)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;ARGV:$&#123;ARGV&#125;&quot;</span>)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;ARGV0:$&#123;ARGV0&#125;,ARGV1:$&#123;ARGV1&#125;&quot;</span>)</span><br><span class="line">	<span class="keyword">message</span>(<span class="string">&quot;argn:$&#123;ARGN&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_function2(hello world <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 调用，这里多出来的参数就是未命名参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">============= my_function2 =============</span><br><span class="line">a:hello,b:world</span><br><span class="line">ARGC:<span class="number">5</span></span><br><span class="line">ARGV:hello;world;<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span></span><br><span class="line">ARGV0:hello,ARGV1:world</span><br><span class="line">argn:<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img src="/2025/12/07/CMake%20Memo/image-20251125170609319-1764061572541-1.png" alt=""></p>
<p><code>ARGVn</code>，n是访问第几个未命名参数，以0开始(0-based)，<strong>n&lt;ARGC，否则未定义行为</strong></p>
<ul>
<li>关键字参数</li>
</ul>
<p>这个比较复杂，可以查相关资料，个人觉得用处不大</p>
</li>
<li>
<p>函数返回值：</p>
</li>
</ol>
<p>返回值获取例子（引用）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example_func3</span></span><br><span class="line"><span class="comment"># 类似C++函数传引用获取返回值</span></span><br><span class="line"><span class="keyword">function</span>(my_function3 returnValue)</span><br><span class="line">	<span class="keyword">set</span>(<span class="variable">$&#123;returnValue&#125;</span> <span class="string">&quot;hello world&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_function3(result) <span class="comment"># 调用</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;result:$&#123;result&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">result:hello world</span><br></pre></td></tr></table></figure>
<h3 id="宏">- 宏</h3>
<p>和C++的宏类似，都是用字符串替换</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">macro</span>(myMacro arg...)</span><br><span class="line">	<span class="comment"># commands</span></span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>CMake中常用的预定义宏：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">宏</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PROJECT_SOURCE_DIR</td>
<td style="text-align:left">使用cmake命令后紧跟的目录，一般是工程的根目录</td>
</tr>
<tr>
<td style="text-align:left">PROJECT_BINARY_DIR</td>
<td style="text-align:left">执行cmake命令的目录</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_CURRENT_SOURCE_DIR</td>
<td style="text-align:left">当前处理的CMakeLists.txt所在的路径</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_CURRENT_BINARY_DIR</td>
<td style="text-align:left">target 编译目录</td>
</tr>
<tr>
<td style="text-align:left">EXECUTABLE_OUTPUT_PATH</td>
<td style="text-align:left">重新定义目标二进制可执行文件的存放位置</td>
</tr>
<tr>
<td style="text-align:left">LIBRARY_OUTPUT_PATH</td>
<td style="text-align:left">重新定义目标链接库文件的存放位置</td>
</tr>
<tr>
<td style="text-align:left">PROJECT_NAME</td>
<td style="text-align:left">返回通过PROJECT指令定义的项目名称</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_BINARY_DIR</td>
<td style="text-align:left">项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径</td>
</tr>
</tbody>
</table>
<h3 id="List">- List</h3>
<p>官方文档：<a href="https://cmake.org/cmake/help/latest/command/list.html">list — CMake 4.2.0 Documentation</a></p>
<h4 id="1-定义列表">1. 定义列表</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 空列表</span></span><br><span class="line"><span class="keyword">set</span>(my_list <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 初始化（空格分隔，含空格元素用引号）</span></span><br><span class="line"><span class="keyword">set</span>(numbers <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"><span class="keyword">set</span>(strings <span class="string">&quot;a b&quot;</span> c <span class="string">&quot;d e&quot;</span>)  <span class="comment"># 实际元素：&quot;a b&quot;、c、&quot;d e&quot;（共3个元素）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从变量拼接生成列表</span></span><br><span class="line"><span class="keyword">set</span>(prefix <span class="string">&quot;file_&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(suffixes <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="keyword">set</span>(files <span class="variable">$&#123;prefix&#125;</span><span class="number">1</span> <span class="variable">$&#123;prefix&#125;</span><span class="number">2</span>)  <span class="comment"># files = &quot;file_1 file_2&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-访问元素与长度">2. 访问元素与长度</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义列表</span></span><br><span class="line"><span class="keyword">set</span>(my_list <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表长度</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH my_list len)  <span class="comment"># len = 元素个数</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;len:$&#123;len&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引访问（0开始，负索引则是反的）</span></span><br><span class="line"><span class="keyword">list</span>(GET my_list <span class="number">0</span> first_elem)  <span class="comment"># 获取第1个元素</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;first_elem:$&#123;first_elem&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(GET my_list -<span class="number">1</span> last_elem)  <span class="comment"># 倒数第1个元素</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;last_elem:$&#123;last_elem&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-添加元素（APPEND-PREPEND）">3. 添加元素（APPEND/PREPEND）</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(my_list <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;初始列表: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 末尾添加（单个/多个元素）</span></span><br><span class="line"><span class="keyword">list</span>(APPEND my_list <span class="number">3</span> <span class="number">4</span>)  <span class="comment"># my_list = 1 2 3 4</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;APPEND 后: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开头添加</span></span><br><span class="line"><span class="keyword">list</span>(PREPEND my_list <span class="number">0</span>)  <span class="comment"># my_list = 0 1 2 3 4</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PREPEND 后: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入到指定索引（索引2位置插入5）</span></span><br><span class="line"><span class="keyword">list</span>(INSERT my_list <span class="number">2</span> <span class="number">5</span>)  <span class="comment"># my_list = 0 1 5 2 3 4</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;INSERT 后: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4-删除元素（REMOVE-AT-REMOVE-ITEM-REMOVE-DUPLICATES）">4. 删除元素（REMOVE_AT/REMOVE_ITEM/REMOVE_DUPLICATES）</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(my_list <span class="number">0</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;初始列表: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引删除（删除第3个元素，索引2）</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_AT my_list <span class="number">2</span>)  <span class="comment"># my_list = 0 1 2 3 4 2</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;REMOVE_AT 后: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按值删除（删除所有值为2的元素）</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM my_list <span class="number">2</span>)  <span class="comment"># my_list = 0 1 3 4</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;REMOVE_ITEM 后: &#x27;$&#123;my_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重（保留首次出现的元素）</span></span><br><span class="line"><span class="keyword">set</span>(dup_list a b a c b)</span><br><span class="line"><span class="keyword">list</span>(REMOVE_DUPLICATES dup_list) <span class="comment"># dup_list = a b c</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;REMOVE_DUPLICATES 后: &#x27;$&#123;dup_list&#125;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="5-查找（FIND）">5. 查找（FIND）</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(my_list a b c d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找元素位置（返回索引，未找到返回-1）</span></span><br><span class="line"><span class="keyword">list</span>(FIND my_list <span class="string">&quot;c&quot;</span> idx)  <span class="comment"># idx = 2</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;元素 &#x27;c&#x27; 的索引: $&#123;idx&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(FIND my_list <span class="string">&quot;x&quot;</span> idx)  <span class="comment"># idx = -1</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;元素 &#x27;x&#x27; 的索引: $&#123;idx&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="6-拼接和切片（JOIN-SUBLIST）">6. 拼接和切片（JOIN/SUBLIST）</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(my_list <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：从索引1开始，取3个元素（索引1、2、3）</span></span><br><span class="line"><span class="keyword">list</span>(SUBLIST my_list <span class="number">1</span> <span class="number">3</span> sub_list)  <span class="comment"># sub_list = 1 2 3</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;SUBLIST 结果: &#x27;$&#123;sub_list&#125;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接：用指定字符连接列表为字符串</span></span><br><span class="line"><span class="keyword">list</span>(JOIN my_list <span class="string">&quot;,&quot;</span> str)  <span class="comment"># str = &quot;0,1,2,3,4&quot;</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;JOIN 结果: &#x27;$&#123;str&#125;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="7-排序（SROT）">7. 排序（SROT）</h4>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(SORT &lt;<span class="keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>
<p><code>COMPARE &lt;compare&gt;</code>：排序规则（默认 <code>STRING</code>）：</p>
<ul>
<li><code>STRING</code>：按字母 / 数字字符串排序（默认）。</li>
<li><code>FILE_BASENAME</code>：按文件基名排序（如 <code>a/1.txt</code>、<code>b/2.txt</code> 按 <code>1.txt</code>、<code>2.txt</code> 排序）。</li>
<li><code>NATURAL</code>：自然排序（如 <code>file10.txt</code> 排在 <code>file2.txt</code> 后，默认 <code>STRING</code> 会相反）。</li>
</ul>
</li>
<li>
<p><code>CASE &lt;case&gt;</code>：大小写敏感度（默认 <code>SENSITIVE</code>）：</p>
<ul>
<li><code>SENSITIVE</code>：区分大小写（默认，<code>A</code> &lt; <code>a</code>）。</li>
<li><code>INSENSITIVE</code>：不区分大小写（<code>A</code> = <code>a</code>）。</li>
</ul>
</li>
<li>
<p><code>ORDER &lt;order&gt;</code>：排序顺序（默认 <code>ASCENDING</code>）：</p>
<ul>
<li><code>ASCENDING</code>：升序（默认）。</li>
<li><code>DESCENDING</code>：降序。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 默认排序（STRING + SENSITIVE + ASCENDING）</span></span><br><span class="line"><span class="keyword">set</span>(strings Z a B <span class="number">10</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">list</span>(SORT strings)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;默认排序：$&#123;strings&#125;&quot;</span>)  <span class="comment"># 输出结果：默认排序：10 2 B Z a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 自然排序（解决数字字符串排序问题）</span></span><br><span class="line"><span class="keyword">list</span>(SORT strings COMPARE NATURAL)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;自然排序：$&#123;strings&#125;&quot;</span>)  <span class="comment"># 输出结果：自然排序：2 10 a B Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 不区分大小写 + 降序</span></span><br><span class="line"><span class="keyword">set</span>(letters A b C a)</span><br><span class="line"><span class="keyword">list</span>(SORT letters CASE INSENSITIVE ORDER DESCENDING)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;不区分大小写降序：$&#123;letters&#125;&quot;</span>)  <span class="comment"># 输出结果：不区分大小写降序：C b A a</span></span><br></pre></td></tr></table></figure>
<h4 id="8-翻转列表（REVERSE）">8. 翻转列表（REVERSE）</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(order <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"><span class="keyword">list</span>(REVERSE order)  <span class="comment"># 翻转列表</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;翻转后：$&#123;order&#125;&quot;</span>)  <span class="comment"># 输出结果：翻转后：4 3 2 1</span></span><br></pre></td></tr></table></figure>
<h3 id="math">- math()</h3>
<p><strong>命令格式</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">math</span>(EXPR &lt;输出变量&gt; <span class="string">&quot;&lt;算术表达式&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>支持的运算符</strong>：<code>+</code>（加）、<code>-</code>（减）、<code>*</code>（乘）、<code>/</code>（整数除法）、<code>%</code>（取模）</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="number">10</span>)</span><br><span class="line"><span class="keyword">set</span>(b <span class="number">3</span>)</span><br><span class="line"><span class="keyword">math</span>(EXPR sum <span class="string">&quot;$&#123;a&#125; + $&#123;b&#125;&quot;</span>)        <span class="comment"># 加法：13</span></span><br><span class="line"><span class="keyword">math</span>(EXPR diff <span class="string">&quot;$&#123;a&#125; - $&#123;b&#125;&quot;</span>)       <span class="comment"># 减法：7</span></span><br><span class="line"><span class="keyword">math</span>(EXPR product <span class="string">&quot;$&#123;a&#125; * $&#123;b&#125;&quot;</span>)    <span class="comment"># 乘法：30</span></span><br><span class="line"><span class="keyword">math</span>(EXPR quotient <span class="string">&quot;$&#123;a&#125; / $&#123;b&#125;&quot;</span>)   <span class="comment"># 整数除法：3（10/3=3.333，取整）</span></span><br><span class="line"><span class="keyword">math</span>(EXPR remainder <span class="string">&quot;$&#123;a&#125; % $&#123;b&#125;&quot;</span>)  <span class="comment"># 取模：1（10%3=1）</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;和：$&#123;sum&#125;，商：$&#123;quotient&#125;，余数：$&#123;remainder&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：和：13，商：3，余数：1</span></span><br></pre></td></tr></table></figure>
<h3 id="搜索文件">- 搜索文件</h3>
<p>如果一个项目里边的源文件很多，在编写<strong>CMakeLists.txt</strong>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令。</p>
<ol>
<li>方式1<br>
在 CMake 中使用<code>aux_source_directory</code> 命令可以查找某个路径下的所有源文件，命令格式为：<br>
<code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code></li>
</ol>
<ul>
<li>
<p>dir：要搜索的目录</p>
</li>
<li>
<p>variable：将从dir目录下搜索到的源文件列表存储到该变量中</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURC&#125;</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方式2<br>
如果一个项目里边的源文件很多，在编写<strong>CMakeLists.txt</strong>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是<strong>file（当然，除了搜索以外通过 file 还可以做其他事情）</strong>。</li>
</ol>
<p><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></p>
<ul>
<li>
<p>GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</p>
</li>
<li>
<p>GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</p>
</li>
</ul>
<p>搜索当前目录的src目录下所有的源文件，并存储到变量中</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。</p>
</li>
<li>
<p>关于要搜索的文件路径和类型可加双引号，也可不加:</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="实用示例">实用示例</h2>
<h3 id="防止在源树构建">- 防止在源树构建</h3>
<ul>
<li>
<p><code>CMAKE_SOURCE_DIR</code>：CMakeLists.txt 所在目录（源树）</p>
</li>
<li>
<p><code>CMAKE_BINARY_DIR</code>：CMake构建目录</p>
</li>
<li>
<p><code>FATAL_ERROR</code>：严重错误，会中断CMake后面的命令</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 避免在源树创建</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Error: In-source builds are not allowed.</span></span><br><span class="line"><span class="string">    Please create a separate directory for build files, such as a &#x27;build&#x27; directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h3 id="确保CMAKE-BUILD-TYPE为单配置生成器指定默认值">- 确保CMAKE_BUILD_TYPE为单配置生成器指定默认值</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保CMAKE_BUILD_TYPE为单配置生成器指定默认值</span></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> CMAKE_BUILD_TYPE <span class="keyword">OR</span> CMAKE_BUILD_TYPE <span class="keyword">STREQUAL</span> <span class="string">&quot;&quot;</span>) <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">DEFINED</span> CMAKE_CONFIGURATION_TYPES)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span></span><br><span class="line">        <span class="string">&quot;Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel Coverage.&quot;</span></span><br><span class="line">        FORCE)  <span class="comment"># FORCE 强制覆盖已定义但为空的情况</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试 Memo</title>
    <url>/2025/12/19/GDB%E8%B0%83%E8%AF%95%20Memo/</url>
    <content><![CDATA[<h1>GDB调试 Memo</h1>
<h3 id="核心概述">核心概述</h3>
<p>GDB是GNU开源调试器，与GCC配套，支持多语言（C/C++/Ada等）、多系统，为字符界面操作。核心功能：程序启停控制、断点管理、代码查看、变量监控、单步调试等。</p>
<p>吉祥物：射手鱼（Archer Fish），寓意“精准捕杀bug”。</p>
<h2 id="一、调试准备（关键前提）">一、调试准备（关键前提）</h2>
<p>编译程序时必须添加调试选项，否则无法使用GDB调试。</p>
<p>- 核心选项：<code>-g</code>（在可执行文件中嵌入源代码关联信息，不嵌入完整源文件，调试时需保证源文件可访问）</p>
<p>- 推荐可选选项：</p>
<ul>
<li><code>-O0</code>：关闭编译器优化，避免代码执行逻辑与源码不一致</li>
<li><code>-Wall</code>：开启所有警告，提前规避潜在bug</li>
</ul>
<p>- 编译示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># C程序编译</span></span><br><span class="line">gcc -g -O0 -Wall args.c -o app</span><br><span class="line"><span class="comment"># C++程序编译</span></span><br><span class="line">g++ -g -O0 -Wall test.cpp -o test_app</span><br></pre></td></tr></table></figure>
<p>注意：带<code>-g</code>的可执行文件体积会略大（如示例中app 9816字节 vs 无-g的app1 8608字节）。</p>
<h2 id="二、GDB启停与参数设置">二、GDB启停与参数设置</h2>
<h3 id="2-1-启动GDB">2.1 启动GDB</h3>
<p>- 命令格式：<code>gdb 可执行程序名</code></p>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb app  <span class="comment"># 启动GDB并关联app程序，此时程序未执行</span></span><br><span class="line">(gdb)  <span class="comment"># 进入GDB交互模式，等待输入调试命令</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-给程序传命令行参数">2.2 给程序传命令行参数</h3>
<p>适用场景：调试需要命令行参数的程序（如main(int argc, char* argv[])），需在程序启动前设置。</p>
<p>- 核心命令：</p>
<ul>
<li>设置参数：<code>set args 参数1 参数2 ...</code></li>
<li>查看参数：<code>show args</code></li>
</ul>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> args 11 22 33 44 55  <span class="comment"># 给app设置命令行参数11-55</span></span><br><span class="line">(gdb) show args  <span class="comment"># 验证参数</span></span><br><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;11 22 33 44 55&quot;</span>.</span><br></pre></td></tr></table></figure>
<h3 id="2-3-启动被调试程序">2.3 启动被调试程序</h3>
<p>调试中仅能启动一次，两种启动方式：</p>
<ul>
<li><code>run</code>（缩写<code>r</code>）：无断点则执行完程序；有断点则停在第一个断点</li>
<li><code>start</code>：停在main函数第一行，等待后续调试命令</li>
</ul>
<p>- 后续继续运行：<code>continue</code>（缩写<code>c</code>），从当前阻塞位置继续，直到下一个有效断点</p>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) start  <span class="comment"># 启动程序，停在main第一行</span></span><br><span class="line">(gdb) c       <span class="comment"># 继续运行程序</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-退出GDB">2.4 退出GDB</h3>
<p>- 命令：<code>quit</code>（缩写<code>q</code>）</p>
<p>- 示例：<code>(gdb) q  # 终止GDB进程，退出调试</code></p>
<h2 id="三、代码查看命令（list-l）">三、代码查看命令（list/l）</h2>
<p>无可视化界面时，通过命令查看源码，辅助定位断点位置。命令：<code>list</code>（缩写<code>l</code>），默认一次显示10行。</p>
<h3 id="3-1-查看当前文件（默认main函数所在文件）">3.1 查看当前文件（默认main函数所在文件）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) l          <span class="comment"># 从第一行开始显示</span></span><br><span class="line">(gdb) l 15       <span class="comment"># 显示第15行附近的代码</span></span><br><span class="line">(gdb) l main     <span class="comment"># 显示main函数附近的代码</span></span><br><span class="line"><span class="comment"># 回车：重复上一次list命令，查看后续内容</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-切换并查看其他文件">3.2 切换并查看其他文件</h3>
<p>- 命令格式：<code>l 文件名:行号</code> 或 <code>l 文件名:函数名</code></p>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) l insert.cpp:8    <span class="comment"># 切换到insert.cpp，显示第8行附近代码</span></span><br><span class="line">(gdb) l test.cpp:<span class="built_in">sort</span>   <span class="comment"># 切换到test.cpp，显示sort函数附近代码</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-调整显示行数">3.3 调整显示行数</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> listsize 20  <span class="comment"># 设置一次显示20行</span></span><br><span class="line">(gdb) show listsize     <span class="comment"># 查看当前显示行数设置</span></span><br><span class="line">listsize is 20.</span><br></pre></td></tr></table></figure>
<h2 id="四、断点操作（核心调试功能）">四、断点操作（核心调试功能）</h2>
<p>断点命令：<code>break</code>（缩写<code>b</code>），用于让程序在指定位置阻塞，便于观察状态。</p>
<h3 id="4-1-设置断点">4.1 设置断点</h3>
<ul>
<li>普通断点（当前文件）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b 12        <span class="comment"># 在当前文件第12行设断点</span></span><br><span class="line">(gdb) b main      <span class="comment"># 在main函数第一行设断点</span></span><br></pre></td></tr></table></figure>
<ul>
<li>普通断点（非当前文件）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b test.cpp:16    <span class="comment"># 在test.cpp第16行设断点</span></span><br><span class="line">(gdb) b insert.cpp:insertionSort  <span class="comment"># 在insert.cpp的insertionSort函数设断点</span></span><br></pre></td></tr></table></figure>
<ul>
<li>条件断点（仅满足条件时阻塞，常用于循环）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b 20 <span class="keyword">if</span> i==10  <span class="comment"># 第20行设断点，仅当变量i等于10时生效</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-查看断点信息">4.2 查看断点信息</h3>
<p>- 命令：<code>info break</code>（缩写<code>i b</code>）</p>
<p>- 示例及字段说明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) i b</span><br><span class="line">Num  Type        Disp Enb Address         What</span><br><span class="line">1    breakpoint  keep y   0x0000000000400cb5 <span class="keyword">in</span> main() at test.cpp:12</span><br><span class="line"><span class="comment"># Num：断点编号（操作断点的关键标识）</span></span><br><span class="line"><span class="comment"># Enb：状态（y=可用，n=不可用）</span></span><br><span class="line"><span class="comment"># What：断点位置（文件+行号/函数）</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-删除断点">4.3 删除断点</h3>
<p>- 命令：<code>delete</code>（缩写<code>del/d</code>）+ 断点编号/区间</p>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) d 1          <span class="comment"># 删除编号1的断点</span></span><br><span class="line">(gdb) d 2 4 6      <span class="comment"># 删除编号2、4、6的断点</span></span><br><span class="line">(gdb) d 1-5        <span class="comment"># 删除编号1到5的连续断点</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-切换断点状态（启用-禁用）">4.4 切换断点状态（启用/禁用）</h3>
<p>临时不用的断点无需删除，可设置为禁用状态。</p>
<ul>
<li>禁用断点：<code>disable</code>（缩写<code>dis</code>）+ 编号/区间</li>
<li>启用断点：<code>enable</code>（缩写<code>ena</code>）+ 编号/区间</li>
</ul>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) dis 2 4      <span class="comment"># 禁用编号2、4的断点</span></span><br><span class="line">(gdb) ena 2-5      <span class="comment"># 启用编号2到5的断点</span></span><br><span class="line">(gdb) i b          <span class="comment"># 验证状态（Enb列变为y/n）</span></span><br></pre></td></tr></table></figure>
<h2 id="五、核心调试命令（程序阻塞后使用）">五、核心调试命令（程序阻塞后使用）</h2>
<h3 id="5-1-变量查看与打印">5.1 变量查看与打印</h3>
<h4 id="5-1-1-手动打印变量值（print-p）">5.1.1 手动打印变量值（print/p）</h4>
<p>- 命令：<code>print</code>（缩写<code>p</code>），支持格式化输出。</p>
<p>- 格式化字符表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式化字符（/fmt）</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/x</td>
<td style="text-align:left">十六进制（整数）</td>
</tr>
<tr>
<td style="text-align:left">/d</td>
<td style="text-align:left">有符号十进制（整数）</td>
</tr>
<tr>
<td style="text-align:left">/u</td>
<td style="text-align:left">无符号十进制（整数）</td>
</tr>
<tr>
<td style="text-align:left">/o</td>
<td style="text-align:left">八进制（整数）</td>
</tr>
<tr>
<td style="text-align:left">/t</td>
<td style="text-align:left">二进制（整数）</td>
</tr>
<tr>
<td style="text-align:left">/f</td>
<td style="text-align:left">浮点数格式</td>
</tr>
<tr>
<td style="text-align:left">/c</td>
<td style="text-align:left">字符格式</td>
</tr>
</tbody>
</table>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p i          <span class="comment"># 十进制打印变量i</span></span><br><span class="line"><span class="variable">$5</span> = 3</span><br><span class="line">(gdb) p/x i        <span class="comment"># 十六进制打印变量i</span></span><br><span class="line"><span class="variable">$6</span> = 0x3</span><br><span class="line">(gdb) p/o i        <span class="comment"># 八进制打印变量i</span></span><br><span class="line"><span class="variable">$7</span> = 03</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-查看变量类型（ptype）">5.1.2 查看变量类型（ptype）</h4>
<p>- 命令：<code>ptype 变量名</code></p>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) ptype i       <span class="comment"># 查看变量i的类型</span></span><br><span class="line"><span class="built_in">type</span> = int</span><br><span class="line">(gdb) ptype array   <span class="comment"># 查看数组array的类型</span></span><br><span class="line"><span class="built_in">type</span> = int [12]</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-自动打印变量（display）">5.1.3 自动打印变量（display）</h4>
<p>区别于print：程序每次暂停（如单步、断点）时自动打印，适合跟踪变量变化。</p>
<ul>
<li>设置自动打印：<code>display 变量名</code> 或 <code>display/fmt 变量名</code></li>
<li>查看自动打印列表：<code>info display</code>（缩写<code>i display</code>）</li>
<li>取消自动打印：<code>undisplay 编号</code> 或 <code>delete display 编号</code></li>
<li>禁用/启用自动打印：<code>disable display 编号</code> / <code>enable display 编号</code></li>
</ul>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) display i        <span class="comment"># 自动打印变量i</span></span><br><span class="line">(gdb) display/x array[i]  <span class="comment"># 十六进制自动打印array[i]</span></span><br><span class="line">(gdb) i display        <span class="comment"># 查看列表</span></span><br><span class="line">Auto-display expressions now <span class="keyword">in</span> effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  i</span><br><span class="line">2:   y  /x array[i]</span><br><span class="line">(gdb) undisplay 1      <span class="comment"># 取消编号1的自动打印</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-单步调试">5.2 单步调试</h3>
<p>程序阻塞后，逐行/逐函数调试，观察执行流程。</p>
<ul>
<li><code>step</code>（缩写<code>s</code>）：逐行执行，<strong>会进入函数体内部</strong></li>
<li><code>next</code>（缩写<code>n</code>）：逐行执行，<strong>不进入函数体内部</strong>（函数整体执行）</li>
<li><code>finish</code>：从当前函数体内部跳出（需确保函数内无有效断点）</li>
<li><code>until</code>：直接跳出循环体（条件：循环内无有效断点，需在循环开始/结束行执行）</li>
</ul>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) s          <span class="comment"># 单步执行，进入函数</span></span><br><span class="line">(gdb) finish     <span class="comment"># 跳出当前函数</span></span><br><span class="line">(gdb) n          <span class="comment"># 单步执行，不进入函数</span></span><br><span class="line">(gdb) <span class="keyword">until</span>      <span class="comment"># 跳出循环</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-手动设置变量值">5.3 手动设置变量值</h3>
<p>适用场景：快速让变量达到目标值（如循环因子、特殊条件值），提高调试效率。</p>
<p>- 命令：<code>set var 变量名=目标值</code></p>
<p>- 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> var i=90  <span class="comment"># 直接将变量i设为90</span></span><br><span class="line">(gdb) <span class="built_in">set</span> var count=0  <span class="comment"># 将循环因子count设为0，重新执行循环</span></span><br></pre></td></tr></table></figure>
<h2 id="六、高频命令速查表">六、高频命令速查表</h2>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">完整命令</th>
<th style="text-align:left">缩写</th>
<th style="text-align:left">核心用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">启动GDB</td>
<td style="text-align:left">gdb 可执行程序</td>
<td style="text-align:left">-</td>
<td style="text-align:left">gdb app</td>
</tr>
<tr>
<td style="text-align:left">启动程序</td>
<td style="text-align:left">run</td>
<td style="text-align:left">r</td>
<td style="text-align:left">r（停在第一个断点）</td>
</tr>
<tr>
<td style="text-align:left">启动停main函数</td>
<td style="text-align:left">start</td>
<td style="text-align:left">-</td>
<td style="text-align:left">start</td>
</tr>
<tr>
<td style="text-align:left">继续运行</td>
<td style="text-align:left">continue</td>
<td style="text-align:left">c</td>
<td style="text-align:left">c（到下一个断点）</td>
</tr>
<tr>
<td style="text-align:left">设断点</td>
<td style="text-align:left">break</td>
<td style="text-align:left">b</td>
<td style="text-align:left">b 12、b main、b test.cpp:8</td>
</tr>
<tr>
<td style="text-align:left">查看断点</td>
<td style="text-align:left">info break</td>
<td style="text-align:left">i b</td>
<td style="text-align:left">i b（查编号、状态）</td>
</tr>
<tr>
<td style="text-align:left">删除断点</td>
<td style="text-align:left">delete</td>
<td style="text-align:left">d</td>
<td style="text-align:left">d 1、d 2-5</td>
</tr>
<tr>
<td style="text-align:left">单步（进函数）</td>
<td style="text-align:left">step</td>
<td style="text-align:left">s</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">单步（不进函数）</td>
<td style="text-align:left">next</td>
<td style="text-align:left">n</td>
<td style="text-align:left">n</td>
</tr>
<tr>
<td style="text-align:left">打印变量</td>
<td style="text-align:left">print</td>
<td style="text-align:left">p</td>
<td style="text-align:left">p i、p/x i</td>
</tr>
<tr>
<td style="text-align:left">查看代码</td>
<td style="text-align:left">list</td>
<td style="text-align:left">l</td>
<td style="text-align:left">l、l 15、l test.cpp:main</td>
</tr>
<tr>
<td style="text-align:left">退出GDB</td>
<td style="text-align:left">quit</td>
<td style="text-align:left">q</td>
<td style="text-align:left">q</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Memo</title>
    <url>/2025/10/29/Git%20Memo/</url>
    <content><![CDATA[<h1><font style=background:#FFFDF6 color="DarkGoldenRod">Git Memo</font></h1>
<p><font style=background:#FFFDF6 color="DarkGoldenRod"><strong>作者: ol</strong></font><br>
<font style=background:#FFFDF6 color="DarkGoldenRod"> ⚠著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</font></p>
<blockquote>
<p><font style=background:#EBFAF3 color="green">💡参考：</font><br>
<font style=background:#EBFAF3 color="green"><a href="https://www.bilibili.com/video/BV1HM411377j/?share_source=copy_web&amp;vd_source=ca9b60cf240586ea52bbc59b3756a3df">【GeekHour】一小时Git教程</a></font><br>
<font style=background:#EBFAF3 color="green"><a href="https://git-scm.com/doc">Git官方文档</a></font></p>
</blockquote>
<p><img src="/2025/10/29/Git%20Memo/Git-Cheet-Sheet-ByGeekHour.png" alt="Git备忘录"></p>
<h2 id="初始化设置">初始化设置</h2>
<ul>
<li><code>git config --global user.name &quot;你的用户名&quot;</code>：配置用户名</li>
<li><code>git config --global user.email &quot;你的邮箱&quot;</code>：配置邮箱</li>
<li><code>git config --global credential.helper store</code>：存储凭证</li>
<li><code>git config --list</code>：查看所有配置（包括全局、本地和系统级）</li>
</ul>
<h2 id="创建仓库">创建仓库</h2>
<ul>
<li>
<p><code>git init &lt;project-name&gt;</code>：创建一个新的本地仓库（省略 project-name 则在当前目录创建）</p>
</li>
<li>
<p><code>git clone &lt;url&gt;</code>：克隆一个远程仓库</p>
</li>
</ul>
<h2 id="四个区域">四个区域</h2>
<ul>
<li>
<p>工作区 (Working Directory)：就是你在电脑里能实际看到的目录</p>
</li>
<li>
<p>暂存区 (Stage/Index)：暂存区也叫索引，用来临时存放未提交的内容，一般在.git 目录下的 index 中</p>
</li>
<li>
<p>本地仓库 (Repository)：Git 在本地的版本库，仓库信息存储在.git 这个隐藏目录中</p>
</li>
<li>
<p>远程仓库 (Remote Repository)：托管在远程服务器上的仓库，常用的有 GitHub、GitLab、Gitee</p>
</li>
</ul>
<h2 id="添加和提交">添加和提交</h2>
<ul>
<li>
<p><code>git add &lt;file&gt;</code>：添加一个文件到暂存区，比如<code>git add .</code>就表示添加所有文件到暂存区</p>
</li>
<li>
<p><code>git commit -m &quot;message&quot;</code>：提交所有暂存区的文件到本地仓库</p>
</li>
<li>
<p><code>git commit -am &quot;message&quot;</code>：提交所有已修改的文件到本地仓库</p>
</li>
</ul>
<h2 id="文件操作">文件操作</h2>
<ul>
<li>
<p><code>git mv &lt;file&gt; &lt;new-file&gt;</code>：移动一个文件到新的位置</p>
</li>
<li>
<p><code>git rm &lt;file&gt;</code>：从工作区和暂存区删除一个文件，并且将这次删除放入暂存区</p>
</li>
<li>
<p><code>git rm --cached &lt;file&gt;</code>：从索引 / 暂存区中删除文件，但是本地工作区文件还在，只是不希望这个文件被版本控制</p>
</li>
<li>
<p><code>git checkout &lt;file&gt; &lt;commit-id&gt;</code>：恢复一个文件到之前的版本</p>
</li>
<li>
<p><code>git restore --staged &lt;file&gt;</code>：撤销暂存区的文件，重新放回工作区（git add 的反向操作）</p>
</li>
</ul>
<h2 id="查看状态或差异">查看状态或差异</h2>
<ul>
<li>
<p><code>git status</code>：查看仓库状态，列出还未提交的新的或修改的文件</p>
</li>
<li>
<p><code>git log --oneline</code>：查看提交历史，–oneline 表示简介模式</p>
</li>
<li>
<p><code>git diff</code>：查看未暂存的文件更新了哪些部分</p>
</li>
<li>
<p><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;</code>：查看两个提交之间的差异</p>
</li>
<li>
<p><code>git reflog</code>：Reference Log（引用日志），查看本地仓库中所有分支引用（包括 HEAD）的移动历史</p>
</li>
</ul>
<h2 id="撤销和恢复">撤销和恢复</h2>
<ul>
<li>
<p><code>git reset --mixed &lt;commit-id&gt;</code>：重置当前分支的 HEAD 为之前的某个提交，–mixed 参数表示重置工作区</p>
</li>
<li>
<p><code>git reset --hard &lt;commit-id&gt;</code>：重置当前分支的 HEAD 为之前的某个提交，–hard 参数表示重置工作区和暂存区</p>
</li>
<li>
<p><code>git reset --soft &lt;commit-id&gt;</code>：重置当前分支的 HEAD 为之前的某个提交，–soft 参数表示重置暂存区</p>
</li>
<li>
<p><code>git revert &lt;commit-id&gt;</code>：创建一个新的提交，用来撤销指定的提交，后者的所有变化将被前者抵消，并且应用到当前分支</p>
</li>
</ul>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-06_17-57-54.png" alt="git reset的三种模式"></p>
<h2 id="分支">分支</h2>
<ul>
<li>
<p><code>git branch</code>：查看所有本地分支，当前分支前面会有一个星号 *，-r 查看远程分支，-a 查看所有分支</p>
</li>
<li>
<p><code>git branch &lt;branch-name&gt;</code>：创建一个新的分支</p>
</li>
<li>
<p><code>git checkout &lt;branch-name&gt;</code>：切换到指定分支，并更新工作区（旧版本，有歧义，不推荐）</p>
</li>
<li>
<p><code>git switch &lt;branch-name&gt;</code>：切换到指定分支，并更新工作区（新版本，无歧义，推荐）</p>
</li>
<li>
<p><code>git checkout -b &lt;branch-name&gt;</code>：创建并切换到新的分支（旧版本，有歧义，不推荐）</p>
</li>
<li>
<p><code>git switch -b &lt;branch-name&gt;</code>：创建并切换到新的分支（新版本，无歧义，推荐）</p>
</li>
<li>
<p><code>git merge --no-ff -m &quot;message&quot; &lt;branch-name&gt;</code>：合并分支，–no-ff 参数表示禁用 Fast Forward 模式，合并后的历史有分支，能看出曾经做过合并；-ff 参数表示使用 FastForward 模式，合并后的历史会变成一条直线</p>
</li>
<li>
<p><code>git branch -d &lt;branch-name&gt;</code>：删除一个已经合并的分支</p>
</li>
<li>
<p><code>git branch -D &lt;branch-name&gt;</code>：删除一个分支，不管是否合并</p>
</li>
<li>
<p><code>git switch &lt;dev&gt;</code>：切换到 dev 分支</p>
</li>
<li>
<p><code>git rebase &lt;main&gt;</code>：rebase 操作可以把本地未 push 的分叉提交历史整理成直线，看起来更加直观。但是，如果多人协作时，不要对已经推送到远程的分支执行 rebase 操作。rebase 不会产生新的提交，而是把当前分支的每一个提交都 “复制” 到目标分支上，然后再把当前分支指向目标分支，而 merge 会产生一个新的提交，这个提交有两个分支的所有修改</p>
</li>
<li>
<p><code>git squash &lt;branch-name&gt;</code>：合并 &amp; 挤压（squash）所有提交到一个提交</p>
</li>
<li>
<p><code>git log --graph --oneline --decorate --all</code>：简洁直观的方式展示仓库的提交历史和分支关系</p>
<p><strong>参数含义：</strong></p>
<ul>
<li><code>--graph</code>：在输出中添加 ASCII 图形，可视化展示分支之间的合并历史和关系（用竖线、斜线等表示分支走向）。</li>
<li><code>--oneline</code>：将每个提交压缩为一行显示，只包含提交哈希值的前 7 位和提交信息摘要，非常简洁。</li>
<li><code>--decorate</code>：显示提交所关联的引用（如分支名、标签名、远程分支等），直观看到每个提交属于哪个分支。</li>
<li><code>--all</code>：显示所有分支的提交历史，而不仅仅是当前分支的历史，便于查看多分支并行开发的情况。</li>
</ul>
</li>
</ul>
<p>​		觉得太长可以取一个别名<strong>graph</strong>，下次直接输入graph就可以调用了。</p>
<p>​		命令：<code>alias graph=&quot;git log --graph --oneline --decorate --all&quot;</code></p>
<h2 id="远程仓库">远程仓库</h2>
<ul>
<li>
<p><code>git remote add &lt;remote-name&gt; &lt;remote-url&gt;</code>：添加远程仓库</p>
</li>
<li>
<p><code>git remote -v</code>：查看远程仓库</p>
</li>
<li>
<p><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;</code>：重命名远程仓库</p>
</li>
<li>
<p><code>git remote rm &lt;remote-name&gt;</code>：删除远程仓库</p>
</li>
<li>
<p><code>git pull &lt;remote-name&gt; &lt;branch-name&gt;</code>：从远程仓库拉取代码，默认拉取远程仓库名 origin 的 master 或者 main 分支</p>
</li>
<li>
<p><code>git pull --rebase</code>：将本地改动的代码 rebase 到远程仓库的最新代码上（为了有一个干净、线性的提交历史）</p>
</li>
<li>
<p><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code>：推送代码到远程仓库（然后再发起 pull request）</p>
</li>
<li>
<p><code>git push -u &lt;remote&gt; &lt;local-branch&gt;:&lt;remote-branch&gt;</code>：推送本地分支到远程分支并关联跟踪关系</p>
</li>
<li>
<p><code>git fetch &lt;remote-name&gt;</code>：获取所有远程分支</p>
</li>
<li>
<p><code>git branch -r</code>：查看远程分支</p>
</li>
<li>
<p><code>git fetch &lt;remote-name&gt; &lt;branch-name&gt;</code>：Fetch 某一个特定的远程分支</p>
</li>
</ul>
<h2 id="Stash">Stash</h2>
<ul>
<li>
<p><code>git stash save &quot;message&quot;</code>：Stash 操作可以把当前工作现场 “储藏” 起来，等以后恢复现场后继续工作。-u 参数表示把所有未跟踪的文件也一并存储；-a 参数表示把所有未跟踪的文件和忽略的文件也一并存储；save 参数表示存储的信息，可以不写</p>
</li>
<li>
<p><code>git stash list</code>：查看所有 stash</p>
</li>
<li>
<p><code>git stash pop</code>：恢复最近一次 stash，pop 会把 stash 内容删除</p>
</li>
<li>
<p><code>git stash pop stash@&#123;2&#125;</code>：恢复指定的 stash，stash@{2} 表示第三个 stash，stash@{0} 表示最近的 stash</p>
</li>
<li>
<p><code>git stash apply</code>：重新接受最近一次 stash，apply 不会把 stash 内容删除</p>
</li>
<li>
<p><code>git stash drop stash@&#123;2&#125;</code>：删除指定的 stash</p>
</li>
<li>
<p><code>git stash clear</code>：删除所有 stash</p>
</li>
</ul>
<h2 id="标签">标签</h2>
<ul>
<li><code>git tag &lt;tag-name&gt;</code>：给当前的提交打上标签，通常用于版本发布</li>
</ul>
<h2 id="特殊文件">特殊文件</h2>
<ul>
<li>
<p><code>.git</code>：Git 仓库的元数据和对象数据库</p>
</li>
<li>
<p><code>.gitignore</code>：忽略文件，不需要提交到仓库的文件</p>
</li>
<li>
<p><code>.gitattributes</code>：指向当前分支的指针</p>
</li>
<li>
<p><code>.gitkeep</code>：使空目录被提交到仓库</p>
</li>
<li>
<p><code>.gitmodules</code>：记录子模块的信息</p>
</li>
<li>
<p><code>.gitconfig</code>：记录仓库的配置信息</p>
</li>
</ul>
<h2 id="特殊符号">特殊符号</h2>
<ul>
<li>
<p><code>main/master</code>：默认主分支</p>
</li>
<li>
<p><code>origin</code>：默认远程仓库</p>
</li>
<li>
<p><code>HEAD</code>：指向当前分支的指针</p>
</li>
<li>
<p><code>HEAD^</code>：上一个版本</p>
</li>
<li>
<p><code>HEAD~4</code>：上四个版本</p>
</li>
</ul>
<h2 id="代理">代理</h2>
<ul>
<li><code>git config --global --unset http.proxy</code>：取消HTTP代理</li>
<li><code>git config --global --unset https.proxy</code>：取消HTTPS代理</li>
<li><code>git config --global http.proxy http://127.0.0.1:33210</code>：设置HTTP代理</li>
<li><code>git config --global https.proxy https://127.0.0.1:33210</code>：设置HTTPS代理</li>
</ul>
<h2 id="更新">更新</h2>
<ul>
<li><code>git update-git-for-windows</code>：更新windows版本</li>
</ul>
<h2 id="gitignore文件">.gitignore文件</h2>
<ul>
<li>匹配规则</li>
</ul>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_09-57-00.png" alt=".gitignore文件的匹配规则"></p>
<ul>
<li>示例</li>
</ul>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_09-57-34.png" alt=".gitignore文件的示例"></p>
<ul>
<li>各种.gitignore文件模板(<a href="https://github.com/github/gitignore">github/gitignore: A collection of useful .gitignore templates</a>)</li>
</ul>
<h2 id="SSH秘钥">SSH秘钥</h2>
<ol>
<li>
<p>首先到用户的根目录的.ssh文件夹下</p>
<ul>
<li>Windows：<code>C:\Users\用户名\.ssh</code></li>
</ul>
</li>
<li>
<p>生成ssh秘钥<code>ssh-keygen -t rsa -b 4096</code></p>
<p><strong>参数含义</strong>：</p>
<ul>
<li><code>-t</code>  参数（密钥类型）</li>
</ul>
<p><code>-t</code> 是 <code>type</code> 的缩写，用于指定要生成的 SSH 密钥的加密算法类型 。这里 <code>rsa</code> 表示使用 RSA（Rivest-Shamir-Adleman）算法，它是一种非对称加密算法，在 SSH 密钥体系里是比较经典、应用广泛的一种，不过也有更现代的如 <code>ed25519</code> 等算法（若用 <code>ed25519</code> 算法，命令可写成 <code>ssh-keygen -t ed25519</code> ，在很多场景下它性能和安全性表现更优 ）。</p>
<ul>
<li><code>-b</code>  参数（密钥长度）</li>
</ul>
<p><code>-b</code> 是 <code>bits</code> 的缩写，用于指定密钥的长度（位数）。<code>4096</code> 表示生成 4096 位长度的 RSA 密钥 。密钥长度越长，理论上破解难度越大、安全性越高，但同时生成和使用时的计算开销也会稍大。RSA 密钥常见的还有 2048 位（若不指定 <code>-b</code>，RSA 密钥默认长度一般是 3072 位左右，不同版本 <code>ssh-keygen</code> 可能有差异 ），4096 位在当下能提供较高的安全级别，很多场景会推荐使用。</p>
<p>执行这条命令后，通常会提示你指定密钥文件的保存路径（默认是 <code>~/.ssh/id_rsa</code> 及对应公钥 <code>id_rsa.pub</code> ），还可设置密钥的密码（passphrase，按需选择，设置后使用密钥时需额外输入该密码，增强安全性） 。生成的私钥（<code>id_rsa</code> 这类文件）要妥善保管，公钥（<code>id_rsa.pub</code> 这类）可配置到 GitHub、GitLab 等平台用于身份认证 。</p>
</li>
<li>
<p>默认会是id_rsa名字，如果不是第一次需要输入一次文件名，输入空会覆盖之前的id_rsa文件而且<strong>不可逆</strong></p>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_10-25-37.png" alt="输入文件名"></p>
</li>
<li>
<p>id_rsa是私钥文件，id_rsa.pub是公钥文件，私钥文件不要上传不要给任何人，公钥文件上传到代码托管平台（如github）上</p>
</li>
<li>
<p>在github的设置中，把公钥文件的内容复制到ssh的Key里面。</p>
</li>
</ol>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_10-33-51.png" alt="公钥上传"></p>
<ol start="6">
<li>创建一个config文件，把下面的内容放进去</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile C:\Users\用户名\.ssh\秘钥文件名</span><br></pre></td></tr></table></figure>
<h2 id="VScode的Git状态">VScode的Git状态</h2>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_14-02-25.png" alt="Git状态"></p>
<h2 id="GitFlow">GitFlow</h2>
<p>GitFlow 是一种流程模型，用于在 Git 上管理软件开发项目。</p>
<ul>
<li>
<p>主分支 (master/main)：代表了项目的稳定版本，每个提交到主分支的代码都应该是经过测试和审核的</p>
</li>
<li>
<p>开发分支 (develop)：用于日常开发。所有的功能分支、发布分支和修补分支都应该从开发分支派生出来</p>
</li>
<li>
<p>功能分支 (feature)：用于开发单独的功能或者特性。每个功能分支都应该从开发分支派生，并在开发完成后合并回开发分支</p>
</li>
<li>
<p>发布分支 (release)：用于准备项目发布。发布分支应该从开发分支派生，并在准备好发布版本后合并回主分支和开发分支</p>
</li>
<li>
<p>热修复分支 (hotfix)：用于修复主分支上的紧急问题。热修复分支应该从主分支派生，并在修复完成后，合并回主分支和开发分支</p>
</li>
</ul>
<h3 id="版本号规则">版本号规则</h3>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_16-45-30.png" alt="版本号规则"></p>
<h3 id="分支命名规范">分支命名规范</h3>
<p><img src="/2025/10/29/Git%20Memo/Snipaste_2025-08-07_16-54-38.png" alt="分支命名规范"></p>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile Memo</title>
    <url>/2025/12/07/Makefile%20Memo/</url>
    <content><![CDATA[<h1>Makefile Memo</h1>
<h3 id="一、Makefile的核心作用">一、Makefile的核心作用</h3>
<ul>
<li>
<p>单文件工程用GCC命令编译便捷，多文件/大型工程中GCC力不从心，需借助make工具实现自动化编译</p>
</li>
<li>
<p>make是解释makefile指令的命令工具，多数IDE内置（如VC++的nmake、QtCreator的qmake）</p>
</li>
<li>
<p>makefile定义工程编译规则（文件编译顺序、重编译条件等），支持执行系统命令，类似Shell脚本</p>
</li>
<li>
<p>优势：一旦写好，执行<code>make</code>命令即可完成全工程自动编译，大幅提升开发效率</p>
</li>
<li>
<p>命名与位置：支持<code>makefile</code>和<code>Makefile</code>两种命名；<code>make</code>命令在哪个目录执行，就加载该目录下的makefile；一个项目可在不同目录放置多个makefile</p>
</li>
</ul>
<h3 id="二、规则（Makefile框架核心）">二、规则（Makefile框架核心）</h3>
<h4 id="1-基本格式">1. 基本格式</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每条规则的语法格式:</span></span><br><span class="line"><span class="section">target1,target2...: depend1, depend2, ...</span></span><br><span class="line">	command</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<h4 id="2-三部分组成">2. 三部分组成</h4>
<ul>
<li>
<p>目标（target）：与命令对应，可生成同名文件；支持多目标；不生成文件仅执行动作的目标称为“伪目标”</p>
</li>
<li>
<p>依赖（depend）：规则执行的必需条件，可使用目标文件（如*.o）；依赖可为空；可引用其他规则的目标，形成规则嵌套；支持多个依赖</p>
</li>
<li>
<p>命令（command）：规则的执行动作（如编译、生成库、进入目录等），多为Shell命令；支持多个命令，每个命令前必须有Tab缩进且独占一行</p>
</li>
</ul>
<h4 id="3-示例">3. 示例</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例1：单目标、多依赖、单命令（源文件a.c/b.c/c.c生成可执行程序app）</span></span><br><span class="line"><span class="section">app:a.c b.c c.c</span></span><br><span class="line">	gcc a.c b.c c.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：多目标、多依赖、多命令</span></span><br><span class="line"><span class="section">app,app1:a.c b.c c.c d.c</span></span><br><span class="line">	gcc a.c b.c -o app</span><br><span class="line">	gcc c.c d.c -o app1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例3：规则嵌套（通过子规则生成依赖文件*.o）</span></span><br><span class="line"><span class="section">app:a.o b.o c.o</span></span><br><span class="line">	gcc a.o b.o c.o -o app</span><br><span class="line"><span class="section">a.o:a.c</span></span><br><span class="line">	gcc -c a.c</span><br><span class="line"><span class="section">b.o:b.c</span></span><br><span class="line">	gcc -c b.c</span><br><span class="line"><span class="section">c.o:c.c</span></span><br><span class="line">	gcc -c c.c</span><br></pre></td></tr></table></figure>
<h3 id="三、工作原理">三、工作原理</h3>
<h4 id="1-规则的执行逻辑">1. 规则的执行逻辑</h4>
<ul>
<li>
<p>make命令优先查找Makefile中第一条规则，分析并执行动作</p>
</li>
<li>
<p>若规则依赖不存在，该规则命令无法执行，需新增规则将缺失依赖作为目标，生成依赖后再执行原规则</p>
</li>
<li>
<p>执行非第一条规则：需在make后指定目标，如<code>make b.o</code>（仅执行生成b.o的规则）</p>
</li>
</ul>
<h4 id="2-文件的时间戳（重编译判断依据）">2. 文件的时间戳（重编译判断依据）</h4>
<ul>
<li>
<p>正常情况：目标时间戳 &gt; 所有依赖时间戳 → 不执行规则命令</p>
</li>
<li>
<p>依赖更新：目标时间戳 &lt; 部分依赖时间戳 → 重新执行规则命令生成目标</p>
</li>
<li>
<p>目标不存在：必执行规则命令生成目标</p>
</li>
</ul>
<p>示例：修改a.c后执行make，仅重新生成a.o和app，其他目标（b.o、c.o）不重新编译</p>
<h4 id="3-自动推导（make的默认规则）">3. 自动推导（make的默认规则）</h4>
<ul>
<li>
<p>编译.c文件时，无需手动写.c→.o的规则，make会自动匹配默认规则：用<code>cc -c</code>编译.c文件生成对应的.o文件</p>
</li>
<li>
<p>只需指定.o目标，make会自动寻找对应的.c依赖并执行默认编译命令</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目目录含add.c/div.c/main.c/mult.c/sub.c/head.h/makefile</span></span><br><span class="line"><span class="comment"># makefile仅一条规则，make会自动推导生成所有.o依赖</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行make的输出（自动调用cc -c生成.o）：</span></span><br><span class="line"><span class="comment"># cc    -c -o add.o add.c</span></span><br><span class="line"><span class="comment"># cc    -c -o div.o div.c</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span></span><br></pre></td></tr></table></figure>
<h3 id="四、变量（提升规则灵活性）">四、变量（提升规则灵活性）</h3>
<p>分为自定义变量、预定义变量、自动变量三类</p>
<h4 id="1-自定义变量">1. 自定义变量</h4>
<ul>
<li>
<p>定义：<code>变量名=变量值</code>（无类型，必须赋值）</p>
</li>
<li>
<p>引用：<code>$(变量名)</code></p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：用自定义变量简化规则</span></span><br><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc  <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<h4 id="2-预定义变量（可直接使用，无需定义）">2. 预定义变量（可直接使用，无需定义）</h4>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>生成静态库的程序名称</td>
<td>ar</td>
</tr>
<tr>
<td>CC</td>
<td>C语言编译器名称</td>
<td>cc</td>
</tr>
<tr>
<td>CXX</td>
<td>C++语言编译器名称</td>
<td>g++</td>
</tr>
<tr>
<td>RM</td>
<td>删除文件程序名称</td>
<td>rm -f</td>
</tr>
<tr>
<td>CFLAGS</td>
<td>C语言编译器选项</td>
<td>无</td>
</tr>
<tr>
<td>CXXFLAGS</td>
<td>C++语言编译器选项</td>
<td>无</td>
</tr>
</tbody>
</table>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：结合自定义变量和预定义变量</span></span><br><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line">CFLAGS=-O3 <span class="comment"># 代码优化选项</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        <span class="variable">$(CC)</span>  <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-自动变量（仅在规则命令中使用，代表目标-依赖）">3. 自动变量（仅在规则命令中使用，代表目标/依赖）</h4>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$*</td>
<td>目标文件名（不含扩展名）</td>
</tr>
<tr>
<td>$+</td>
<td>所有依赖文件（按顺序，含重复）</td>
</tr>
<tr>
<td>$&lt;</td>
<td>第一个依赖文件名称</td>
</tr>
<tr>
<td>$?</td>
<td>所有比目标时间戳晚的依赖文件</td>
</tr>
<tr>
<td>$@</td>
<td>目标文件名（含扩展名）</td>
</tr>
<tr>
<td>$^</td>
<td>所有不重复的依赖文件</td>
</tr>
</tbody>
</table>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：用自动变量简化命令</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="comment"># 等价于 gcc add.o div.o main.o mult.o sub.o -o calc</span></span><br></pre></td></tr></table></figure>
<h4 id="4-赋值语法">4. 赋值语法</h4>
<table>
<thead>
<tr>
<th>语法</th>
<th>含义</th>
<th>示例</th>
<th>最终值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>延迟赋值（使用变量时才展开）</td>
<td><code>A = $(B)``B = hello</code></td>
<td><code>A = hello</code></td>
</tr>
<tr>
<td><code>:=</code></td>
<td>立即赋值（定义时就展开）</td>
<td><code>A := $(B)``B = hello</code></td>
<td><code>A = </code>（定义 A 时 B 还未赋值）</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>追加赋值（基于现有值加新内容）</td>
<td><code>A = a``A += b c</code></td>
<td><code>A = a b c</code></td>
</tr>
<tr>
<td><code>?=</code></td>
<td>仅变量未定义时赋值（避免覆盖）</td>
<td><code>A ?= hello``A ?= world</code></td>
<td><code>A = hello</code></td>
</tr>
</tbody>
</table>
<h3 id="五、模式匹配（精简冗余规则）">五、模式匹配（精简冗余规则）</h3>
<h4 id="1-作用">1. 作用</h4>
<p>多个.c→.o的规则语法重复（命令均为<code>gcc *.c -c</code>），可通过模式匹配整理为一个规则模板</p>
<h4 id="2-模板格式">2. 模板格式</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">%.o:%.c  # %是通配符，匹配文件名（不含后缀）</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c  <span class="comment"># $&lt; 指代第一个依赖文件（即%.c）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-效果">3. 效果</h4>
<p>替代所有单个.c→.o的规则，如add.o:add.c、div.o:div.c等，大幅精简makefile</p>
<h3 id="六、常用函数（均有返回值，格式：-函数名-参数1-参数2-…-）">六、常用函数（均有返回值，格式：$(函数名 参数1,参数2,…)）</h3>
<h4 id="1-wildcard（获取指定目录下指定类型文件）">1. wildcard（获取指定目录下指定类型文件）</h4>
<ul>
<li>
<p>原型：<code>$(wildcard PATTERN...)</code></p>
</li>
<li>
<p>参数：PATTERN为目录+文件类型（如*.c、./sub/*.c），多目录用空格分隔</p>
</li>
<li>
<p>返回值：空格分隔的符合条件的文件名列表</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：搜索3个目录下的.c文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span></span><br><span class="line"><span class="comment"># 返回值：/home/robin/a/a.c /home/robin/a/b.c ... e.c f.c</span></span><br></pre></td></tr></table></figure>
<h4 id="2-patsubst（按模式替换文件名后缀）">2. patsubst（按模式替换文件名后缀）</h4>
<ul>
<li>
<p>原型：<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></p>
</li>
<li>
<p>参数：pattern（待替换后缀模式，如%.c）、replacement（新后缀模式，如%.o）、text（原始文件列表）</p>
</li>
<li>
<p>返回值：替换后的文件名列表</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：将src中的.cpp后缀替换为.o</span></span><br><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj值：a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure>
<h3 id="七、Makefile编写进化过程（从简单到标准）">七、Makefile编写进化过程（从简单到标准）</h3>
<p>项目目录：add.c/div.c/main.c/mult.c/sub.c/head.h</p>
<h4 id="版本1：简单但低效（修改一个文件全量重编译）">版本1：简单但低效（修改一个文件全量重编译）</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">calc:add.c  div.c  main.c  mult.c  sub.c</span></span><br><span class="line">        gcc add.c  div.c  main.c  mult.c  sub.c -o calc</span><br></pre></td></tr></table></figure>
<h4 id="版本2：分模块编译（提升效率，规则冗余）">版本2：分模块编译（提升效率，规则冗余）</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">        gcc add.c -c</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">        gcc div.c -c</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">        gcc main.c -c</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc sub.c -c</span><br><span class="line"><span class="section">mult.o:mult.c</span></span><br><span class="line">        gcc mult.c -c</span><br></pre></td></tr></table></figure>
<h4 id="版本3：变量-模式匹配（精简规则）">版本3：变量+模式匹配（精简规则）</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$(obj)</span>  -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure>
<h4 id="版本4：函数自动获取文件（解放双手）">版本4：函数自动获取文件（解放双手）</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>  <span class="comment"># 自动搜索当前目录所有.c文件</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span>  <span class="comment"># 自动替换为.o</span></span><br><span class="line">target=calc</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$(obj)</span>  -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure>
<h4 id="版本5：添加清理规则（存在伪目标问题）">版本5：添加清理规则（存在伪目标问题）</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=calc</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$(obj)</span>  -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -c</span><br><span class="line"><span class="comment"># 清理生成文件（伪目标，无对应实体文件）</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<p>问题：若目录存在clean文件，make clean会提示“clean is up to date”，无法执行删除</p>
<h4 id="版本6：最终版（声明伪目标，优化清理命令）">版本6：最终版（声明伪目标，优化清理命令）</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=calc</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$(obj)</span>  -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -c</span><br><span class="line"><span class="comment"># 声明clean为伪目标，make不检测时间戳</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        -rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span>  <span class="comment"># -表示强制执行，失败不终止</span></span><br><span class="line">        echo <span class="string">&quot;清理完成&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="八、练习题（多目录项目Makefile）">八、练习题（多目录项目Makefile）</h3>
<h4 id="项目目录结构">项目目录结构</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h  # 声明加减乘除函数</span><br><span class="line">├── main.c      # 测试程序，调用head.h函数</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c   # 加法实现</span><br><span class="line">    ├── div.c   # 除法实现</span><br><span class="line">    ├── mult.c  # 乘法实现</span><br><span class="line">    └── sub.c   # 减法实现</span><br></pre></td></tr></table></figure>
<h4 id="对应的Makefile">对应的Makefile</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target = app  <span class="comment"># 最终目标名</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c ./src/*.c)</span>  <span class="comment"># 搜索当前目录和src目录的.c文件</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span>  <span class="comment"># 替换为.o文件</span></span><br><span class="line">include=./<span class="keyword">include</span>  <span class="comment"># 头文件目录</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o <span class="variable">$@</span>  <span class="comment"># 链接所有.o生成可执行程序</span></span><br><span class="line"><span class="comment"># 编译时指定头文件目录（-I选项）</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -c -I <span class="variable">$(include)</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 声明伪目标，清理生成文件</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        -rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br></pre></td></tr></table></figure>
<h3 id="九、多目录工程Makefile框架（范式）">九、多目录工程Makefile框架（范式）</h3>
<p>本框架是复杂多目录项目的标准化编译方案，整合「顶层Makefile」和「顶层Makefile.build」核心功能，只需在各级子目录通过<code>obj-y</code>指定编译文件/子目录，即可实现全工程一键编译/清理，支持交叉编译和精细化编译控制。</p>
<h4 id="1-完整框架代码">1. 完整框架代码</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一、工具链与全局变量定义（顶层Makefile核心）</span></span><br><span class="line">CROSS_COMPILE = </span><br><span class="line">AS		= <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD		= <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC		= <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP		= <span class="variable">$(CC)</span> -E</span><br><span class="line">AR		= <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM		= <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line"></span><br><span class="line">STRIP		= <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY		= <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP		= <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出变量，使子目录Makefile可使用</span></span><br><span class="line"><span class="keyword">export</span> AS LD CC CPP AR NM</span><br><span class="line"><span class="keyword">export</span> STRIP OBJCOPY OBJDUMP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译选项：-Wall开启所有警告，-O2优化，-g生成调试信息；追加头文件目录</span></span><br><span class="line">CFLAGS := -Wall -O2 -g</span><br><span class="line">CFLAGS += -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接选项（可根据需求添加，如-l指定链接库）</span></span><br><span class="line">LDFLAGS := </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目根目录（当前目录）</span></span><br><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="keyword">export</span> TOPDIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终生成的可执行程序名称</span></span><br><span class="line">TARGET := test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要编译的文件和子目录：obj-y += 文件名 或 子目录/</span></span><br><span class="line">obj-y += main.o</span><br><span class="line">obj-y += sub.o</span><br><span class="line">obj-y += a/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、核心目标规则（顶层Makefile核心）</span></span><br><span class="line">all : start_recursive_build <span class="variable">$(TARGET)</span></span><br><span class="line">	@echo <span class="variable">$(TARGET)</span> has been built!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发递归编译（调用Makefile.build处理子目录和当前目录编译）</span></span><br><span class="line"><span class="section">start_recursive_build:</span></span><br><span class="line">	make -C ./ -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成最终目标：链接built-in.o（所有目标文件的打包文件）</span></span><br><span class="line"><span class="variable">$(TARGET)</span> : start_recursive_build</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> built-in.o <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理目标文件和可执行程序</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name <span class="string">&quot;*.o&quot;</span>)</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 彻底清理：含依赖文件（.xxx.o.d）</span></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name <span class="string">&quot;*.o&quot;</span>)</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name <span class="string">&quot;*.d&quot;</span>)</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三、递归编译与打包规则（Makefile.build核心）</span></span><br><span class="line"><span class="section">Makefile.build: PHONY := __build</span></span><br><span class="line"><span class="section">__build:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">obj-y :=</span><br><span class="line">subdir-y :=</span><br><span class="line">EXTRA_CFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含当前目录的Makefile（获取该目录的obj-y定义）</span></span><br><span class="line"><span class="keyword">include</span> Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 处理子目录：从obj-y中筛选出子目录（以/结尾），去掉/得到子目录名</span></span><br><span class="line">__subdir-y	:= <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y	+= $(__subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子目录编译产物：每个子目录生成的built-in.o</span></span><br><span class="line">subdir_objs := <span class="variable">$(<span class="built_in">foreach</span> f,$(subdir-y)</span>,<span class="variable">$(f)</span>/built-in.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 处理当前目录目标文件：从obj-y中筛选出非目录文件（即.c对应的.o）</span></span><br><span class="line">cur_objs := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>)</span><br><span class="line"><span class="comment"># 依赖文件：每个.o对应一个.d文件（记录该.o的依赖关系）</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(cur_objs)</span>,.<span class="variable">$(f)</span>.d)</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含依赖文件（若存在），使修改头文件时能触发对应.o重编译</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明伪目标（子目录为伪目标，确保每次都递归编译）</span></span><br><span class="line">PHONY += $(subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 核心编译目标：先编译子目录，再打包当前目录和子目录的目标文件为built-in.o</span></span><br><span class="line">__build : $(subdir-y) built-in.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归编译子目录：进入子目录，执行顶层的Makefile.build</span></span><br><span class="line"><span class="section">$(subdir-y):</span></span><br><span class="line">	make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包目标文件：将当前目录obj和所有子目录的built-in.o合并为当前目录的built-in.o</span></span><br><span class="line">built-in.o : $(subdir-y) <span class="variable">$(cur_objs)</span></span><br><span class="line">	<span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 编译规则：生成.o文件并自动生成依赖文件</span></span><br><span class="line">dep_file = .<span class="variable">$@</span>.d</span><br><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(EXTRA_CFLAGS)</span> $(CFLAGS_<span class="variable">$@</span>) -Wp,-MD,<span class="variable">$(dep_file)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 声明所有PHONY伪目标，避免与同名文件冲突</span></span><br><span class="line">.PHONY : <span class="variable">$(PHONY)</span></span><br></pre></td></tr></table></figure>
<h4 id="2-核心构成与功能拆解">2. 核心构成与功能拆解</h4>
<h5 id="2-1-工具链与全局变量定义（顶层Makefile）">2.1 工具链与全局变量定义（顶层Makefile）</h5>
<ul>
<li>
<p>工具链前缀<code>CROSS_COMPILE</code>：支持交叉编译（如ARM交叉编译可设为<code>arm-linux-gcc-</code>），未设置则使用本地工具链</p>
</li>
<li>
<p>工具定义：<code>AS、LD、CC</code>等编译链接工具，通过<code>CROSS_COMPILE</code>拼接，确保工具链统一</p>
</li>
<li>
<p>全局编译/链接选项：<code>CFLAGS</code>指定警告、优化、头文件目录；<code>LDFLAGS</code>指定链接规则（如链接动态库）</p>
</li>
<li>
<p>导出变量：通过<code>export</code>使子目录的Makefile能继承使用这些变量，保证全工程编译规则一致</p>
</li>
</ul>
<h5 id="2-2-核心目标规则（顶层Makefile）">2.2 核心目标规则（顶层Makefile）</h5>
<ul>
<li>
<p>总目标<code>all</code>：触发递归编译（<code>start_recursive_build</code>）和最终目标生成，执行<code>make</code>时默认执行</p>
</li>
<li>
<p>递归编译触发：<code>start_recursive_build</code>调用<code>Makefile.build</code>，递归处理所有子目录的编译</p>
</li>
<li>
<p>最终目标生成：链接<code>built-in.o</code>（全工程所有目标文件的打包文件）生成可执行程序</p>
</li>
<li>
<p>清理目标：<code>clean</code>清理.o和可执行程序；<code>distclean</code>额外清理依赖文件（.d），适合工程重构</p>
</li>
</ul>
<h5 id="2-3-递归编译与打包规则（Makefile-build）">2.3 递归编译与打包规则（Makefile.build）</h5>
<p>核心作用：标准化各级目录的编译流程，自动处理子目录编译和目标文件打包，无需手动编写每个目录的编译规则。</p>
<ul>
<li>
<p>子目录处理：自动筛选<code>obj-y</code>中的子目录，递归进入子目录执行<code>Makefile.build</code>，生成子目录的<code>built-in.o</code></p>
</li>
<li>
<p>当前目录目标文件处理：筛选<code>obj-y</code>中的.o文件，自动生成依赖文件（.xxx.o.d），确保修改头文件时触发对应.o重编译</p>
</li>
<li>
<p>目标文件打包：通过<code>LD -r</code>（部分链接）将当前目录的.o和所有子目录的<code>built-in.o</code>合并为当前目录的<code>built-in.o</code>，最终顶层目录的<code>built-in.o</code>包含全工程目标文件</p>
</li>
<li>
<p>精细化编译控制：支持<code>EXTRA_CFLAGS</code>（当前目录额外编译选项）、<code>CFLAGS_xxx.o</code>（单个文件专属编译选项）</p>
</li>
</ul>
<h4 id="3-核心工作流程">3. 核心工作流程</h4>
<ol>
<li>
<p>执行<code>make</code>：默认执行顶层Makefile的<code>all</code>目标</p>
</li>
<li>
<p>触发递归编译：调用<code>Makefile.build</code>，从顶层目录开始，递归进入所有<code>obj-y</code>指定的子目录</p>
</li>
<li>
<p>子目录编译：每个子目录生成自身的<code>built-in.o</code>，并向上级目录传递</p>
</li>
<li>
<p>顶层打包与链接：顶层目录合并所有子目录的<code>built-in.o</code>和自身.o，生成顶层<code>built-in.o</code>，最终链接为可执行程序</p>
</li>
</ol>
<h4 id="4-关键配置说明">4. 关键配置说明</h4>
<ul>
<li>
<p><code>obj-y</code> += 文件名/子目录/：核心配置项（y=yes，编译），指定当前目录要编译的文件（如main.o）或要递归编译的子目录（如a/）；多目录框架中约定用obj-y标记“需要参与编译的内容”</p>
</li>
<li>
<p><code>obj-n</code> += 文件名：辅助配置项（n=no，不编译），指定当前目录需排除、不参与编译的文件；需配合filter-out函数过滤，框架不会自动识别，仅为行业约定命名</p>
</li>
<li>
<p><code>obj-m</code> += 文件名：拓展配置项（m=module，模块），常见于Linux内核/驱动开发，指定将文件编译为可加载内核模块（生成.ko文件，而非链接到主程序）</p>
</li>
<li>
<p><code>CROSS_COMPILE</code>：交叉编译时设置，如ARM架构设为<code>arm-none-linux-gnueabi-</code></p>
</li>
<li>
<p><code>CFLAGS += -I 目录</code>：添加头文件搜索目录，确保编译器能找到#include的头文件</p>
</li>
<li>
<p><code>LDFLAGS</code>：添加链接选项，如链接动态库可设为<code>-L ./lib -lm</code>（-L指定库目录，-lm链接数学库）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC Memo</title>
    <url>/2025/11/21/GCC%20Memo/</url>
    <content><![CDATA[<h1>GCC Memo</h1>
<p><code>g++</code> 备忘录涵盖了从基础编译到静态库、动态库创建与使用的常见操作，适合日常开发查阅。</p>
<h2 id="一、基础编译命令">一、基础编译命令</h2>
<h3 id="1-单文件编译（生成可执行文件）">1. 单文件编译（生成可执行文件）</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main  <span class="comment"># 编译 main.cpp，输出可执行文件 main（默认输出 a.out）</span></span><br></pre></td></tr></table></figure>
<h3 id="2-多文件编译">2. 多文件编译</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：直接指定所有源文件</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp func.cpp -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：先生成目标文件（.o），再链接（适合多文件大型项目）</span></span><br><span class="line"></span><br><span class="line">g++ -c main.cpp        <span class="comment"># 生成 main.o（-c：只编译不链接）</span></span><br><span class="line"></span><br><span class="line">g++ -c func.cpp        <span class="comment"># 生成 func.o</span></span><br><span class="line"></span><br><span class="line">g++ main.o func.o -o app  <span class="comment"># 链接所有 .o 文件，生成可执行文件 app</span></span><br></pre></td></tr></table></figure>
<h3 id="3-指定-C-标准">3. 指定 C++ 标准</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -std=c++11  <span class="comment"># 使用 C++11 标准（支持 c++14/c++17/c++20 等）</span></span><br></pre></td></tr></table></figure>
<h3 id="4-包含头文件路径（-I）">4. 包含头文件路径（-I）</h3>
<p>当头文件不在当前目录时，指定头文件搜索路径：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -I./<span class="keyword">include</span>  <span class="comment"># 搜索 ./include 目录下的头文件</span></span><br></pre></td></tr></table></figure>
<h3 id="5-链接系统库（-l）">5. 链接系统库（-l）</h3>
<p>链接系统自带的库（如数学库、线程库）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -lm    <span class="comment"># 链接数学库（math.h，部分系统需显式指定）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o main -lpthread  <span class="comment"># 链接线程库（pthread.h）</span></span><br></pre></td></tr></table></figure>
<h3 id="6-生成调试信息（-g）">6. 生成调试信息（-g）</h3>
<p>用于 GDB 调试：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -g  <span class="comment"># 生成带调试信息的可执行文件</span></span><br></pre></td></tr></table></figure>
<h3 id="7-优化编译（-O）">7. 优化编译（-O）</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -O0  <span class="comment"># 无优化（默认，适合调试）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o main -O1  <span class="comment"># 基础优化（平衡速度和编译时间）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o main -O2  <span class="comment"># 充分优化（推荐发布版本使用）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o main -O3  <span class="comment"># 极致优化（可能增加编译时间和可执行文件大小）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o main -Os  <span class="comment"># 优化代码大小（适合嵌入式场景）</span></span><br></pre></td></tr></table></figure>
<h3 id="8-显示警告信息（-Wall-Wextra）">8. 显示警告信息（-Wall/-Wextra）</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main -Wall  <span class="comment"># 显示所有常见警告（推荐）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o main -Wextra  <span class="comment"># 显示额外警告（更严格）</span></span><br></pre></td></tr></table></figure>
<h2 id="二、静态库（-a）的创建与使用">二、静态库（.a）的创建与使用</h2>
<p>静态库是目标文件（.o）的集合，编译时会被完整复制到可执行文件中，运行时无需依赖库文件。</p>
<p><code>ar</code>和<code>.a</code>的单词是archive，意思是归档</p>
<h3 id="1-步骤-1：生成目标文件（-o）">1. 步骤 1：生成目标文件（.o）</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ -c func1.cpp -o func1.o</span><br><span class="line"></span><br><span class="line">g++ -c func2.cpp -o func2.o</span><br></pre></td></tr></table></figure>
<h3 id="2-步骤-2：打包为静态库（ar-命令）">2. 步骤 2：打包为静态库（ar 命令）</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ar rcs libmylib.a func1.o func2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># ar：打包命令；rcs：r=替换旧文件，c=创建新库，s=生成索引（必须加 s，否则链接失败）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件名格式：libxxx.a（xxx 为库名，链接时用 -lxxx）</span></span><br><span class="line"></span><br><span class="line">ar -t libmylib.a <span class="comment"># 可以查看这个库包含的.o文件</span></span><br></pre></td></tr></table></figure>
<h3 id="3-步骤-3：使用静态库编译可执行文件">3. 步骤 3：使用静态库编译可执行文件</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：直接指定库文件路径和库名</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o app ./libmylib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：用 -L 指定库路径，-l 指定库名（推荐，更简洁）</span></span><br><span class="line"></span><br><span class="line">g++ main.cpp -o app -L./ -lmylib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -L./：搜索当前目录下的库文件；-lmylib：链接 libmylib.a（自动补全 lib 和 .a）</span></span><br></pre></td></tr></table></figure>
<h2 id="三、动态库（-so）的创建与使用">三、动态库（.so）的创建与使用</h2>
<p>动态库在编译时仅记录引用，运行时才加载，可被多个程序共享，无需打包到可执行文件中。</p>
<h3 id="1-步骤-1：生成位置无关代码（-fPIC）">1. 步骤 1：生成位置无关代码（-fPIC）</h3>
<p>位置无关代码（Position-Independent Code）确保库可被加载到内存任意地址：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ -c -fPIC func1.cpp -o func1.o</span><br><span class="line"></span><br><span class="line">g++ -c -fPIC func2.cpp -o func2.o</span><br></pre></td></tr></table></figure>
<h3 id="2-步骤-2：生成动态库（-shared）">2. 步骤 2：生成动态库（-shared）</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ -shared -o libmylib.so func1.o func2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># -shared：指定生成动态库；库文件名格式：libxxx.so（xxx 为库名）</span></span><br></pre></td></tr></table></figure>
<h3 id="3-步骤-3：使用动态库编译可执行文件">3. 步骤 3：使用动态库编译可执行文件</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o app -L./ -lmylib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和静态库用法一致：-L 指定库路径，-l 指定库名（自动补全 lib 和 .so）</span></span><br></pre></td></tr></table></figure>
<h3 id="4-步骤-4：运行动态库程序（解决-“找不到库”-问题）">4. 步骤 4：运行动态库程序（解决 “找不到库” 问题）</h3>
<p>动态库默认搜索路径：<code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code>，若库在当前目录，需手动指定路径：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：临时指定 LD_LIBRARY_PATH（当前终端有效）</span></span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH</span><br><span class="line">./app  <span class="comment"># 此时可正常运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：永久添加库路径（推荐）</span></span><br><span class="line">echo <span class="string">&quot;$PWD&quot;</span> | sudo tee /etc/ld.so.conf.d/mylib.conf  <span class="comment"># 将当前目录写入配置文件</span></span><br><span class="line">sudo ldconfig  <span class="comment"># 更新动态库缓存</span></span><br><span class="line">./app  <span class="comment"># 永久有效</span></span><br></pre></td></tr></table></figure>
<h2 id="四、常用选项速查">四、常用选项速查</h2>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o &lt;file&gt;</code></td>
<td>指定输出文件（可执行文件 / 库文件）</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>只编译不链接，生成 .o 目标文件</td>
</tr>
<tr>
<td><code>-std=&lt;std&gt;</code></td>
<td>指定 C++ 标准（如 c++11/c++17）</td>
</tr>
<tr>
<td><code>-I &lt;dir&gt;</code></td>
<td>添加头文件搜索路径</td>
</tr>
<tr>
<td><code>-L &lt;dir&gt;</code></td>
<td>添加库文件搜索路径</td>
</tr>
<tr>
<td><code>-l &lt;lib&gt;</code></td>
<td>链接库（静态库 libxxx.a 或动态库 <a href="http://libxxx.so">libxxx.so</a>）</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>生成调试信息（供 GDB 调试）</td>
</tr>
<tr>
<td><code>-O&lt;level&gt;</code></td>
<td>优化编译（0/1/2/3/s，0 为无优化）</td>
</tr>
<tr>
<td><code>-Wall</code></td>
<td>显示所有常见警告</td>
</tr>
<tr>
<td><code>-fPIC</code></td>
<td>生成位置无关代码（动态库必需）</td>
</tr>
<tr>
<td><code>-shared</code></td>
<td>生成动态库</td>
</tr>
</tbody>
</table>
<h2 id="五、示例：完整流程（动态库）">五、示例：完整流程（动态库）</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 编写源文件</span></span><br><span class="line">echo &#x27;<span class="comment">#include &quot;func.h&quot;&#x27; &gt; main.cpp</span></span><br><span class="line">echo &#x27;int add(int a, int b) &#123; return a + b; &#125;&#x27; &gt; func.cpp</span><br><span class="line">echo &#x27;int add(int a, int b);&#x27; &gt; func.h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成动态库</span></span><br><span class="line">g++ -c -fPIC func.cpp -o func.o</span><br><span class="line">g++ -shared -o libmylib.so func.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译可执行文件</span></span><br><span class="line">g++ main.cpp -o app -L./ -lmylib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 运行</span></span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=./</span><br><span class="line">./app  <span class="comment"># 输出：（若 main.cpp 调用 add(1,2)，则输出 3）</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>静态库：编译时打包，运行无依赖，文件较大，适合小项目或无需共享的场景。</p>
</li>
<li>
<p>动态库：运行时加载，文件小，可共享，适合大型项目或多程序共用的场景。</p>
</li>
<li>
<p>核心选项：<code>-c</code>（编译）、<code>-shared</code>（动态库）、<code>-fPIC</code>（动态库）、<code>-L/-l</code>（链接库）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Command Memo</title>
    <url>/2025/12/19/Linux-Command%20Memo/</url>
    <content><![CDATA[<h1>Linux-Command Memo</h1>
<h2 id="退出-关闭虚拟机：init-0">退出 / 关闭虚拟机：init 0</h2>
<p><code>init</code>是 Linux 系统初始化进程，运行级别<code>0</code>代表关机（仅 root 权限可执行），用于安全关闭虚拟机 / 服务器，区别于强制断电，会先终止进程、同步数据后关机。</p>
<ul>
<li>
<p>基础用法：<code>init 0</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 0  <span class="comment"># 以root身份执行，安全关闭虚拟机（普通用户需加sudo：sudo init 0）</span></span><br><span class="line"><span class="comment"># 补充：CentOS7+也可使用shutdown命令（更灵活）</span></span><br><span class="line">shutdown -h now  <span class="comment"># 立即关机（等价于init 0）</span></span><br><span class="line">shutdown -h 10  <span class="comment"># 10分钟后关机</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="重启虚拟机：init-6-reboot">重启虚拟机：init 6 /reboot</h2>
<p><code>init 6</code>是传统运行级别重启（执行系统重启流程），<code>reboot</code>是通用重启命令，两者均可安全重启虚拟机，优先推荐<code>reboot</code>更易记。</p>
<ul>
<li>
<p>基础用法：<code>init 6</code> 或 <code>reboot</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 6  <span class="comment"># root权限重启虚拟机（普通用户：sudo init 6）</span></span><br><span class="line">reboot  <span class="comment"># 通用重启命令（无需记运行级别，root/普通用户加sudo均可）</span></span><br><span class="line">reboot -f  <span class="comment"># 强制重启（紧急情况使用，可能丢失未保存数据）</span></span><br><span class="line"><span class="comment"># 补充：shutdown也可实现重启</span></span><br><span class="line">shutdown -r now  <span class="comment"># 立即重启</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看当前工作目录：pwd">查看当前工作目录：pwd</h2>
<p><code>pwd</code>（Print Working Directory）用于显示当前 Shell 会话所在的绝对路径，解决 “不知道自己在哪个目录” 的问题，是最基础的路径定位命令。</p>
<ul>
<li>
<p>基础用法：<code>pwd</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>  <span class="comment"># 输出当前目录（如/home/ubuntu/test）</span></span><br><span class="line"><span class="built_in">pwd</span> -P  <span class="comment"># 显示真实路径（若当前目录是软链接，会指向链接的原始目录）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="切换目录：cd">切换目录：cd</h2>
<p><code>cd</code>（Change Directory）用于切换 Shell 的工作目录，支持绝对路径、相对路径、快捷路径，是目录操作的核心命令。</p>
<ul>
<li>
<p>基础用法：<code>cd [目标目录路径]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local  <span class="comment"># 绝对路径：切换到/usr/local目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span>  <span class="comment"># 相对路径：切换到当前目录下的test子目录</span></span><br><span class="line"><span class="built_in">cd</span> ..  <span class="comment"># 切换到上级目录（..代表父目录）</span></span><br><span class="line"><span class="built_in">cd</span> ~  <span class="comment"># 切换到当前用户的家目录（如/home/ubuntu）</span></span><br><span class="line"><span class="built_in">cd</span> -  <span class="comment"># 切换到上一次所在的目录（快速回切）</span></span><br><span class="line"><span class="built_in">cd</span> /  <span class="comment"># 切换到系统根目录（最顶层目录）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="列出目录内容：ls">列出目录内容：ls</h2>
<p><code>ls</code>（List）用于列出指定目录下的文件 / 目录，默认列出当前目录，搭配参数可显示权限、大小、隐藏文件等详细信息。</p>
<ul>
<li>
<p>基础用法：<code>ls [参数] [目标目录]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span>  <span class="comment"># 列出当前目录的文件/目录（仅名称）</span></span><br><span class="line"><span class="built_in">ls</span> /usr/bin  <span class="comment"># 列出/usr/bin目录下的内容</span></span><br><span class="line"><span class="built_in">ls</span> -l  <span class="comment"># 长格式显示（包含权限、所有者、大小、修改时间，简称ll）</span></span><br><span class="line"><span class="built_in">ls</span> -a  <span class="comment"># 显示所有文件（包含隐藏文件，以.开头的文件）</span></span><br><span class="line"><span class="built_in">ls</span> -lh  <span class="comment"># 人性化显示文件大小（如100M、2G，替代字节数）</span></span><br><span class="line"><span class="built_in">ls</span> -lt  <span class="comment"># 按修改时间排序（最新的在前）</span></span><br><span class="line"><span class="built_in">ls</span> /dir1 /dir2  <span class="comment"># 叠加目录：同时列出dir1和dir2的内容</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="清屏：clear">清屏：clear</h2>
<p>清空终端当前显示的内容，仅隐藏历史输出（并非删除），快捷键<code>Ctrl+L</code>等价于<code>clear</code>，适合终端内容过多时整理界面。</p>
<ul>
<li>
<p>基础用法：<code>clear</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clear  <span class="comment"># 清空终端界面</span></span><br><span class="line"><span class="comment"># 快捷键：Ctrl+L（无需输入命令，更快捷）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看-设置系统时间：date">查看 / 设置系统时间：date</h2>
<p>显示或修改系统当前时间，设置时间需 root 权限，常用于时间同步、日志排查时的时间校准。</p>
<ul>
<li>
<p>基础用法：<code>date [参数] [时间格式/设置值]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span>  <span class="comment"># 显示当前系统时间（如 Thu Dec 18 10:00:00 CST 2025）</span></span><br><span class="line"><span class="built_in">date</span> +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>  <span class="comment"># 自定义格式显示（如 2025-12-18 10:05:30）</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2025-12-18 10:08:00&quot;</span>  <span class="comment"># root权限设置系统时间（普通用户：sudo date -s &quot;...&quot;)</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2025/12/18 10:08:00&quot;</span>  <span class="comment"># 另一种日期格式，效果同上</span></span><br><span class="line"><span class="comment"># 补充：同步硬件时间（避免重启后时间还原）</span></span><br><span class="line">hwclock -w  <span class="comment"># 将系统时间写入硬件时钟（root权限）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="终止进程-放弃输入：Ctrl-C">终止进程 / 放弃输入：Ctrl+C</h2>
<p>终端快捷键，核心作用有两个：① 放弃当前正在输入的命令内容；② 终止前台运行的进程（如正在执行的脚本、curl 请求、ping 命令等）。</p>
<ul>
<li>
<p>基础用法：输入过程中 / 进程运行时按 <code>Ctrl+C</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景1：放弃输入（输入一半不想执行）</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">ls</span> /usr/xxx  <span class="comment"># 输入到一半，按Ctrl+C直接清空输入行</span></span><br><span class="line">[root@localhost ~]#  <span class="comment"># 回到空白输入行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2：终止前台进程（比如持续ping百度）</span></span><br><span class="line">ping www.baidu.com  <span class="comment"># 执行后会持续输出，按Ctrl+C终止</span></span><br><span class="line">^C  <span class="comment"># 终端显示^C，进程停止，回到输入行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查找大文件-磁盘空间分析：du-find">查找大文件 / 磁盘空间分析：du /find</h2>
<p><code>du</code>（Disk Usage）用于统计目录 / 文件的磁盘占用，<code>find</code>用于精准查找指定大小的文件，两者结合可快速定位磁盘占用过大的文件。</p>
<ul>
<li>
<p>基础用法：</p>
<ul>
<li><code>du [参数] 目录</code>：统计目录占用</li>
<li><code>find 路径 -type f -size 大小条件</code>：查找指定大小文件</li>
</ul>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 统计当前目录下一级目录的磁盘占用（按大小降序）</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1 | <span class="built_in">sort</span> -hr</span><br><span class="line"><span class="comment"># -h：人性化显示大小（K/M/G）；--max-depth=1：仅显示一级目录；sort -hr：按大小降序排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找当前目录下大于100M的所有文件（显示详细信息）</span></span><br><span class="line">find . -<span class="built_in">type</span> f -size +100M -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br><span class="line"><span class="comment"># .：当前目录；-type f：仅查找文件（排除目录）；-size +100M：大于100M；-exec：执行后续ls命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 统计指定目录总占用（如/var/log）</span></span><br><span class="line"><span class="built_in">du</span> -sh /var/log  <span class="comment"># -s：汇总总大小；-h：人性化显示</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命令行计算器：bc">命令行计算器：bc</h2>
<p><code>bc</code>是交互式算术计算器，支持整数 / 小数运算、逻辑运算，无需图形界面即可完成简单 / 复杂计算，也可非交互式执行计算。</p>
<ul>
<li>
<p>基础用法：<code>bc</code>（交互式） / <code>echo &quot;计算式&quot; | bc</code>（非交互式）</p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景1：交互式计算（输入bc进入计算器，输入算式回车计算，quit退出）</span></span><br><span class="line">bc</span><br><span class="line">10 + 20  <span class="comment"># 输入后回车，输出30</span></span><br><span class="line">100 / 3  <span class="comment"># 整数除法，输出33</span></span><br><span class="line">scale=2; 100 / 3  <span class="comment"># 设置小数位数为2，输出33.33</span></span><br><span class="line">quit  <span class="comment"># 退出计算器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2：非交互式计算（直接输出结果）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;5 * 8 + 20&quot;</span> | bc  <span class="comment"># 输出60</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;scale=3; (20 - 5) * 2 / 7&quot;</span> | bc  <span class="comment"># 输出4.285</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="开放端口（firewalld）：firewall-cmd">开放端口（firewalld）：firewall-cmd</h2>
<p><code>firewall-cmd</code>是 CentOS7+/RHEL7 + 默认的防火墙管理命令（firewalld），用于配置端口放行、查看防火墙状态，Ubuntu 系统需用<code>ufw</code>（补充在示例中）。</p>
<ul>
<li>
<p>基础用法：<code>firewall-cmd [参数] [端口/协议]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 放行80端口（TCP），永久生效（--permanent）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重新加载防火墙配置（使永久规则生效）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看已开放的所有端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 补充：删除已开放的端口（如删除80端口）</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 查看防火墙状态</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --state  <span class="comment"># 输出running（运行中）/not running（未运行）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Ubuntu系统（ufw防火墙）开放端口示例</span></span><br><span class="line"><span class="built_in">sudo</span> ufw allow 80/tcp  <span class="comment"># 放行80端口</span></span><br><span class="line"><span class="built_in">sudo</span> ufw reload  <span class="comment"># 重载配置</span></span><br><span class="line"><span class="built_in">sudo</span> ufw status  <span class="comment"># 查看开放端口</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="远程连接：SSH">远程连接：SSH</h2>
<p>SSH（Secure Shell）是加密的远程登录协议，用于安全访问 Linux 服务器（替代明文传输的 Telnet），默认端口 22，是远程管理 Linux 的核心方式。</p>
<ul>
<li>
<p>基础用法：<code>ssh [参数] 用户名@目标IP/主机名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 基础连接（默认端口22，需输入密码）</span></span><br><span class="line">ssh root@192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 指定端口连接（服务器SSH端口非22时，如端口2222）</span></span><br><span class="line">ssh -p 2222 root@192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 免密登录配置（无需输入密码，推荐）</span></span><br><span class="line"><span class="comment"># 第一步：本地生成密钥对（一路回车即可，无需设置密码）</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># 第二步：将公钥复制到远程服务器（需输入一次服务器密码）</span></span><br><span class="line">ssh-copy-id root@192.168.1.100</span><br><span class="line"><span class="comment"># 配置完成后，直接ssh root@192.168.1.100即可免密登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 断开SSH连接</span></span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># 或按Ctrl+D</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 后台保持SSH连接（避免超时断开，临时生效）</span></span><br><span class="line">ssh -o ServerAliveInterval=60 root@192.168.1.100</span><br><span class="line"><span class="comment"># 永久生效：编辑~/.ssh/config，添加以下内容</span></span><br><span class="line"><span class="comment"># Host *</span></span><br><span class="line"><span class="comment">#   ServerAliveInterval 60</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看内核日志：dmesg">查看内核日志：dmesg</h2>
<p>用于查看 Linux 内核环形缓冲区的日志信息，包含系统启动时的硬件检测、驱动加载、内核报错 / 警告等内容，是排查硬件、驱动、内核相关问题的核心命令。</p>
<ul>
<li>
<p>基础用法：<code>dmesg</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg  <span class="comment"># 输出所有内核日志</span></span><br><span class="line">dmesg | grep -i error  <span class="comment"># 筛选包含&quot;error&quot;的内核错误日志（忽略大小写）</span></span><br><span class="line">dmesg -T  <span class="comment"># 以人类可读的时间格式显示日志（默认是启动后的时间戳）</span></span><br><span class="line">dmesg | <span class="built_in">head</span> -20  <span class="comment"># 仅查看前20行内核日志</span></span><br><span class="line">dmesg | <span class="built_in">tail</span> -10  <span class="comment"># 仅查看最后10行（最新的内核日志）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="加载脚本配置：source">加载脚本配置：source</h2>
<p>在当前 Shell 会话中执行指定脚本，等价于<code>.</code>（点号），区别于直接执行脚本（会新建子 Shell），执行后脚本中的环境变量、别名等会立即生效。</p>
<ul>
<li>
<p>基础用法：<code>source 脚本路径</code> 或 <code>. 脚本路径</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 重新加载bash配置文件，使配置修改立即生效</span></span><br><span class="line">. /etc/profile  <span class="comment"># 等价于source，加载系统全局环境配置</span></span><br><span class="line"><span class="comment"># 示例：修改~/.bashrc后生效（添加别名）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias ll=&quot;ls -lh&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 执行后ll命令即可使用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查找命令路径：which">查找命令路径：which</h2>
<p>查找指定命令的可执行文件绝对路径，仅检索<code>$PATH</code>环境变量中配置的目录，用于确认命令是否安装、以及当前执行的是哪个版本。</p>
<ul>
<li>
<p>基础用法：<code>which 命令名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> python  <span class="comment"># 查找python命令的可执行路径（如/usr/bin/python3）</span></span><br><span class="line"><span class="built_in">which</span> <span class="built_in">ls</span>  <span class="comment"># 查找ls命令路径（通常为/bin/ls）</span></span><br><span class="line"><span class="built_in">which</span> nginx  <span class="comment"># 若未安装则无输出，安装则显示nginx可执行文件路径</span></span><br><span class="line"><span class="built_in">which</span> -a java  <span class="comment"># 列出所有名为java的可执行文件路径（多个版本时）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="网络数据传输：curl">网络数据传输：curl</h2>
<p>命令行网络工具，支持 HTTP/HTTPS/FTP 等协议，可用于测试接口、下载文件、模拟 HTTP 请求，无需图形界面即可完成网络交互。</p>
<ul>
<li>
<p>基础用法：<code>curl [参数] URL</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://www.baidu.com  <span class="comment"># 访问百度并输出页面内容</span></span><br><span class="line">curl -o baidu.html https://www.baidu.com  <span class="comment"># 下载页面内容保存为baidu.html</span></span><br><span class="line">curl -X POST -d <span class="string">&quot;username=test&amp;pwd=123&quot;</span> https://api.example.com/login  <span class="comment"># 发送POST请求并携带参数</span></span><br><span class="line">curl -I https://www.baidu.com  <span class="comment"># 仅获取HTTP响应头（查看状态码、服务器信息等）</span></span><br><span class="line">curl -s https://www.baidu.com  <span class="comment"># 静默模式（不输出进度条、错误信息）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="端口测试-远程登录：telnet">端口测试 / 远程登录：telnet</h2>
<p>基于 TCP 协议的工具，主要用于测试目标主机的端口是否开放，也可用于简单的远程登录（需先安装 telnet）。</p>
<ul>
<li>
<p>基础用法：<code>telnet 目标IP 端口号</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装telnet（CentOS/Ubuntu）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install telnet -y  <span class="comment"># CentOS/RHEL</span></span><br><span class="line"><span class="built_in">sudo</span> apt install telnet -y  <span class="comment"># Ubuntu/Debian</span></span><br><span class="line"></span><br><span class="line">telnet 192.168.1.100 80  <span class="comment"># 测试192.168.1.100的80端口是否开放</span></span><br><span class="line">telnet www.baidu.com 443  <span class="comment"># 测试百度443端口（HTTPS）是否可达</span></span><br><span class="line"><span class="comment"># 若端口开放：显示&quot;Connected to www.baidu.com&quot;；关闭：显示&quot;Connection refused&quot;</span></span><br><span class="line"><span class="comment"># 退出telnet：按Ctrl+]，再输入quit回车</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置环境变量：export">设置环境变量：export</h2>
<p>用于定义 / 导出环境变量，使变量在当前 Shell 及子 Shell 中生效；若需永久生效，需将命令写入<code>~/.bashrc</code>/<code>/etc/profile</code>等配置文件。</p>
<ul>
<li>
<p>基础用法：<code>export 变量名=值</code>（临时生效）</p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/mybin  <span class="comment"># 新增自定义路径到PATH（临时生效）</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-11-openjdk  <span class="comment"># 设置Java环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>  <span class="comment"># 将Java命令加入PATH（可直接执行java -version）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久生效（追加到bash配置文件）：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export JAVA_HOME=/usr/lib/jvm/java-11-openjdk&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$JAVA_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 重新加载配置使永久变量生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已定义的环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span>  <span class="comment"># 输出Java环境变量路径</span></span><br><span class="line"><span class="built_in">env</span> | grep PATH  <span class="comment"># 筛选查看PATH变量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="创建目录：mkdir">创建目录：mkdir</h2>
<p><code>mkdir</code>（Make Directory）用于创建新目录，支持递归创建多级目录，是文件管理基础命令。</p>
<ul>
<li>
<p>基础用法：<code>mkdir [参数] 目录名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span>  <span class="comment"># 在当前目录创建test目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/test  <span class="comment"># 绝对路径创建test目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p a/b/c  <span class="comment"># 递归创建多级目录（a目录下的b，b下的c）</span></span><br><span class="line"><span class="built_in">mkdir</span> -m 777 public  <span class="comment"># 创建目录并直接设置权限（777为所有用户可读可写可执行）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删除文件-目录：rm">删除文件 / 目录：rm</h2>
<p><code>rm</code>（Remove）用于删除文件或目录，<code>-r</code>递归删除目录，<code>-f</code>强制删除（无提示），使用时需谨慎（避免误删系统文件）。</p>
<ul>
<li>
<p>基础用法：<code>rm [参数] 文件/目录</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.txt  <span class="comment"># 删除当前目录下的test.txt文件（会提示确认，按y回车）</span></span><br><span class="line"><span class="built_in">rm</span> -f test.txt  <span class="comment"># 强制删除test.txt（无提示）</span></span><br><span class="line"><span class="built_in">rm</span> -r testdir  <span class="comment"># 递归删除testdir目录及其中所有内容（需确认）</span></span><br><span class="line"><span class="built_in">rm</span> -rf testdir  <span class="comment"># 强制递归删除目录（无提示，高危！避免执行rm -rf /）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="复制文件-目录：cp">复制文件 / 目录：cp</h2>
<p><code>cp</code>（Copy）用于复制文件或目录，<code>-r</code>递归复制目录，是数据备份常用命令。</p>
<ul>
<li>
<p>基础用法：<code>cp [参数] 源文件/目录 目标路径</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> test.txt /tmp/  <span class="comment"># 复制test.txt到/tmp目录下</span></span><br><span class="line"><span class="built_in">cp</span> -r testdir /tmp/  <span class="comment"># 递归复制testdir目录到/tmp下</span></span><br><span class="line"><span class="built_in">cp</span> -p test.txt /tmp/  <span class="comment"># 复制文件并保留原文件的权限、修改时间</span></span><br><span class="line"><span class="built_in">cp</span> test.txt /tmp/newtest.txt  <span class="comment"># 复制并改名（目标文件名为newtest.txt）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="移动-重命名文件：mv">移动 / 重命名文件：mv</h2>
<p><code>mv</code>（Move）用于移动文件 / 目录，也可用于重命名（同一目录下移动 = 重命名），移动后原路径文件消失。</p>
<ul>
<li>
<p>基础用法：<code>mv 源文件/目录 目标路径/新名称</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> test.txt /tmp/  <span class="comment"># 将test.txt移动到/tmp目录</span></span><br><span class="line"><span class="built_in">mv</span> test.txt newtest.txt  <span class="comment"># 同一目录下重命名（test.txt→newtest.txt）</span></span><br><span class="line"><span class="built_in">mv</span> testdir /usr/local/  <span class="comment"># 移动目录到/usr/local</span></span><br><span class="line"><span class="built_in">mv</span> -f test.txt /tmp/  <span class="comment"># 强制移动（目标存在则覆盖）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看文件内容：cat">查看文件内容：cat</h2>
<p><code>cat</code>（Concatenate）用于查看文件全部内容，适合小文件；大文件推荐用<code>less/more</code>，<code>-n</code>可显示行号。</p>
<ul>
<li>
<p>基础用法：<code>cat [参数] 文件名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.txt  <span class="comment"># 查看test.txt全部内容</span></span><br><span class="line"><span class="built_in">cat</span> -n test.txt  <span class="comment"># 显示内容并标注行号</span></span><br><span class="line"><span class="built_in">cat</span> file1.txt file2.txt &gt; file3.txt  <span class="comment"># 合并file1和file2内容到file3</span></span><br><span class="line"><span class="built_in">cat</span> /dev/null &gt; test.txt  <span class="comment"># 清空test.txt内容（保留文件）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文本搜索：grep">文本搜索：grep</h2>
<p><code>grep</code>是文本过滤工具，用于在文件 / 命令输出中查找包含指定关键词的行，支持正则表达式，是排查日志、配置文件的核心命令。</p>
<ul>
<li>
<p>基础用法：<code>grep [参数] 关键词 文件名/命令输出</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;error&quot;</span> /var/log/messages  <span class="comment"># 在日志文件中查找包含error的行</span></span><br><span class="line">grep -i <span class="string">&quot;error&quot;</span> /var/log/messages  <span class="comment"># 忽略大小写查找</span></span><br><span class="line">grep -n <span class="string">&quot;error&quot;</span> /var/log/messages  <span class="comment"># 显示匹配行的行号</span></span><br><span class="line">grep -v <span class="string">&quot;error&quot;</span> /var/log/messages  <span class="comment"># 反向匹配（排除含error的行）</span></span><br><span class="line"><span class="comment"># 结合管道过滤命令输出</span></span><br><span class="line">ps -ef | grep nginx  <span class="comment"># 查找nginx相关进程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看进程：ps">查看进程：ps</h2>
<p><code>ps</code>（Process Status）用于查看系统中运行的进程，<code>ps -ef</code>/<code>ps aux</code>是最常用的全量进程查看方式。</p>
<ul>
<li>
<p>基础用法：<code>ps [参数]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps  <span class="comment"># 查看当前Shell的进程</span></span><br><span class="line">ps -ef  <span class="comment"># 全量查看所有进程（UID/PID/PPID/COMMAND等）</span></span><br><span class="line">ps aux  <span class="comment"># 以BSD格式查看所有进程（更详细的CPU/内存占用）</span></span><br><span class="line">ps -ef | grep java  <span class="comment"># 筛选java相关进程</span></span><br><span class="line">ps -p 1234  <span class="comment"># 仅查看PID为1234的进程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="终止进程：kill">终止进程：kill</h2>
<p><code>kill</code>用于向进程发送信号，默认发送<code>TERM</code>（终止）信号，<code>-9</code>发送强制终止信号（<code>KILL</code>），需知道进程 PID（通过 ps 获取）。</p>
<ul>
<li>
<p>基础用法：<code>kill [参数] 进程PID</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> 1234  <span class="comment"># 向PID为1234的进程发送终止信号（进程可优雅退出）</span></span><br><span class="line"><span class="built_in">kill</span> -9 1234  <span class="comment"># 强制终止PID为1234的进程（无法拦截，紧急使用）</span></span><br><span class="line"><span class="built_in">kill</span> -l  <span class="comment"># 查看所有可用的信号（如1=HUP，9=KILL，15=TERM）</span></span><br><span class="line"><span class="comment"># 批量终止进程（如终止所有nginx进程）</span></span><br><span class="line">ps -ef | grep nginx | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看磁盘空间：df">查看磁盘空间：df</h2>
<p><code>df</code>（Disk Free）用于查看文件系统的磁盘空间使用情况，<code>-h</code>人性化显示大小（K/M/G），是排查磁盘满的核心命令。</p>
<ul>
<li>
<p>基础用法：<code>df [参数]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>  <span class="comment"># 查看所有文件系统磁盘占用（默认字节数）</span></span><br><span class="line"><span class="built_in">df</span> -h  <span class="comment"># 人性化显示（如/dev/sda1 50G 20G 30G 40% /）</span></span><br><span class="line"><span class="built_in">df</span> -i  <span class="comment"># 查看inode使用情况（inode满也会导致磁盘无法写入）</span></span><br><span class="line"><span class="built_in">df</span> -h /  <span class="comment"># 仅查看根目录（/）的磁盘占用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改文件权限：chmod">修改文件权限：chmod</h2>
<p><code>chmod</code>（Change Mode）用于修改文件 / 目录的访问权限，支持数字权限（777/755 等）和符号权限（u+r、g-w 等），仅文件所有者 /root 可修改。</p>
<ul>
<li>
<p>基础用法：<code>chmod [权限] 文件名/目录</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字权限（r=4，w=2，x=1；u=所有者，g=组，o=其他）</span></span><br><span class="line"><span class="built_in">chmod</span> 755 test.sh  <span class="comment"># 所有者可读可写可执行，组/其他可读可执行（脚本常用）</span></span><br><span class="line"><span class="built_in">chmod</span> 644 test.txt  <span class="comment"># 所有者可读可写，组/其他仅可读（普通文件常用）</span></span><br><span class="line"><span class="built_in">chmod</span> 777 public  <span class="comment"># 所有用户可读可写可执行（测试用，不推荐生产环境）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 符号权限</span></span><br><span class="line"><span class="built_in">chmod</span> u+x test.sh  <span class="comment"># 给所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w test.txt  <span class="comment"># 移除组的写入权限</span></span><br><span class="line"><span class="built_in">chmod</span> o+r test.txt  <span class="comment"># 给其他用户添加读取权限</span></span><br><span class="line"><span class="built_in">chmod</span> -R 755 testdir  <span class="comment"># 递归修改目录及所有子文件权限</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="切换用户：su-sudo">切换用户：su /sudo</h2>
<p><code>su</code>（Switch User）用于切换到其他用户（默认切换到 root），<code>sudo</code>用于以 root 权限执行单条命令（无需切换用户），是权限管理核心命令。</p>
<ul>
<li>
<p>基础用法：</p>
<ul>
<li><code>su [用户名]</code>：切换用户</li>
<li><code>sudo [命令]</code>：以 root 权限执行命令</li>
</ul>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root  <span class="comment"># 切换到root用户（需输入root密码）</span></span><br><span class="line">su - root  <span class="comment"># 切换到root并加载root的环境变量（推荐）</span></span><br><span class="line">su ubuntu  <span class="comment"># 从root切换到普通用户ubuntu（无需密码）</span></span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># 退出切换后的用户，回到原用户</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /root  <span class="comment"># 以root权限查看/root目录（普通用户默认无权限）</span></span><br><span class="line"><span class="built_in">sudo</span> -i  <span class="comment"># 切换到root Shell（等价于su - root）</span></span><br><span class="line"><span class="built_in">sudo</span> passwd ubuntu  <span class="comment"># 重置ubuntu用户密码（root权限）</span></span><br><span class="line"><span class="comment"># 配置sudo免密（需修改/etc/sudoers）</span></span><br><span class="line"><span class="built_in">sudo</span> visudo  <span class="comment"># 编辑sudo配置，添加：ubuntu ALL=(ALL) NOPASSWD: ALL</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="FTP-文件传输：ftp">FTP 文件传输：ftp</h2>
<p>FTP（File Transfer Protocol）是用于服务器与本地之间文件传输的协议，<code>ftp</code>命令是 Linux 下的 FTP 客户端工具，支持文件上传、下载、目录管理等操作，需先安装客户端，默认使用 21 端口。</p>
<ul>
<li>基础用法：<code>ftp [参数] 服务器IP</code>（登录 FTP 服务器），登录后执行内部命令操作文件</li>
<li>常用示例：</li>
</ul>
<h3 id="1-安装-FTP-客户端">1. 安装 FTP 客户端</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS/RHEL系统</span></span><br><span class="line"><span class="built_in">sudo</span> yum install ftp -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu/Debian系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt install ftp -y</span><br></pre></td></tr></table></figure>
<h3 id="2-登录-FTP-服务器（3-种方法）">2. 登录 FTP 服务器（3 种方法）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：直接登录（需后续输入用户名和密码）</span></span><br><span class="line">ftp 192.168.126.131</span><br><span class="line"><span class="comment"># 按提示输入用户名（Name）和密码（Password），登录成功后进入ftp&gt;交互模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：先启动ftp，再连接服务器</span></span><br><span class="line">ftp</span><br><span class="line">ftp&gt; open 192.168.126.131  <span class="comment"># 连接目标IP</span></span><br><span class="line"><span class="comment"># 输入用户名和密码登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：免交互前置登录（直接指定用户和密码）</span></span><br><span class="line">ftp -n 192.168.126.131</span><br><span class="line">ftp&gt; user oracle pwdoracle  <span class="comment"># 格式：user 用户名 密码，直接登录</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：root 用户权限过大，默认不允许登录 FTP 服务器，需使用普通用户。</p>
</blockquote>
<h3 id="3-目录操作（登录后执行）">3. 目录操作（登录后执行）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看FTP服务器当前工作目录</span></span><br><span class="line">ftp&gt; <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换FTP服务器上的目录（目录名含空格需用双引号包裹）</span></span><br><span class="line">ftp&gt; <span class="built_in">cd</span> /freecplus  <span class="comment"># 切换到服务器的/freecplus目录</span></span><br><span class="line">ftp&gt; <span class="built_in">cd</span> <span class="string">&quot;test dir&quot;</span>  <span class="comment"># 切换含空格的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换本地（自己电脑）的工作目录（下载/上传的默认路径）</span></span><br><span class="line">ftp&gt; lcd /tmp  <span class="comment"># 本地文件操作默认路径改为/tmp</span></span><br></pre></td></tr></table></figure>
<h3 id="4-查看-FTP-服务器文件-目录">4. 查看 FTP 服务器文件 / 目录</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出服务器目录/文件的详细信息（类似Linux ls -l）</span></span><br><span class="line">ftp&gt; <span class="built_in">ls</span> /freecplus  <span class="comment"># 查看/freecplus目录详情</span></span><br><span class="line">ftp&gt; <span class="built_in">dir</span> /freecplus  <span class="comment"># 与ls功能一致，用法相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅列出文件名（不显示详细信息）</span></span><br><span class="line">ftp&gt; nlist /freecplus/*.h  <span class="comment"># 列出服务器/freecplus下所有.h文件</span></span><br><span class="line"><span class="comment"># 列出文件名并保存到本地文件</span></span><br><span class="line">ftp&gt; nlist /freecplus/*.h /tmp/freecplus.list  <span class="comment"># 结果输出到本地/tmp/freecplus.list</span></span><br></pre></td></tr></table></figure>
<h3 id="5-文件传输模式（必设！）">5. 文件传输模式（必设！）</h3>
<p>FTP 支持二进制（推荐）和 ASCII 模式，二进制可传输所有文件（压缩包、图片、程序等），ASCII 仅支持文本文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前传输模式</span></span><br><span class="line">ftp&gt; <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换为二进制模式（优先使用，适配所有文件）</span></span><br><span class="line">ftp&gt; bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换为ASCII模式（仅传输.txt/.htm等文本文件）</span></span><br><span class="line">ftp&gt; ascii</span><br></pre></td></tr></table></figure>
<h3 id="6-下载文件（从-FTP-服务器到本地）">6. 下载文件（从 FTP 服务器到本地）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载单个文件（get/recv通用）</span></span><br><span class="line">ftp&gt; get /freecplus/_ftp.h  <span class="comment"># 下载到本地当前目录（lcd设置的路径）</span></span><br><span class="line">ftp&gt; recv /freecplus/_ftp.h /tmp/ftp.h  <span class="comment"># 下载并指定本地保存路径+文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载多个文件（支持通配符）</span></span><br><span class="line">ftp&gt; prompt  <span class="comment"># 关闭逐一确认提示（批量下载必备）</span></span><br><span class="line">ftp&gt; mget /freecplus/*.h  <span class="comment"># 下载服务器/freecplus下所有.h文件到本地</span></span><br></pre></td></tr></table></figure>
<h3 id="7-上传文件（从本地到-FTP-服务器）">7. 上传文件（从本地到 FTP 服务器）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上传单个文件（put/send通用）</span></span><br><span class="line">ftp&gt; put /tmp/test.txt  <span class="comment"># 上传本地/tmp/test.txt到服务器当前目录</span></span><br><span class="line">ftp&gt; send /tmp/test.txt /freecplus/newtest.txt  <span class="comment"># 上传并指定服务器保存路径+文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传多个文件（支持通配符）</span></span><br><span class="line">ftp&gt; prompt  <span class="comment"># 关闭逐一确认提示</span></span><br><span class="line">ftp&gt; mput /tmp/*.txt  <span class="comment"># 上传本地/tmp下所有.txt文件到服务器</span></span><br></pre></td></tr></table></figure>
<h3 id="8-其他常用-FTP-命令">8. 其他常用 FTP 命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名服务器上的文件</span></span><br><span class="line">ftp&gt; rename oldname.txt newname.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除服务器上单个文件</span></span><br><span class="line">ftp&gt; delete test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量删除服务器上的文件</span></span><br><span class="line">ftp&gt; mdelete *.txt  <span class="comment"># 删除服务器当前目录下所有.txt文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在服务器上创建目录</span></span><br><span class="line">ftp&gt; <span class="built_in">mkdir</span> newdir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除服务器上的目录</span></span><br><span class="line">ftp&gt; <span class="built_in">rmdir</span> newdir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看FTP命令帮助（不输入命令名则显示所有帮助）</span></span><br><span class="line">ftp&gt; <span class="built_in">help</span>  <span class="comment"># 显示所有FTP命令帮助</span></span><br><span class="line">ftp&gt; <span class="built_in">help</span> get  <span class="comment"># 查看get命令的具体用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出FTP连接</span></span><br><span class="line">ftp&gt; <span class="built_in">bye</span>  <span class="comment"># 或quit，断开连接并退出ftp模式</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<ol>
<li>目录名含特殊字符（如空格）需用双引号包裹；</li>
<li>批量上传 / 下载前执行<code>prompt</code>关闭确认提示，提高效率；</li>
<li>本地操作权限由执行 ftp 命令的用户决定，服务器操作权限由 FTP 登录用户决定；</li>
<li>若连接失败，需检查服务器 21 端口是否开放（<code>firewall-cmd --list-ports</code>）。</li>
</ol>
<h2 id="编译构建：make">编译构建：make</h2>
<p><code>make</code>是基于 Makefile 的项目构建工具，自动执行编译、链接等操作，简化多文件项目的编译流程，支持并行编译、清理编译产物等核心操作。</p>
<ul>
<li>
<p>基础用法：<code>make [参数/目标]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make  <span class="comment"># 执行Makefile默认目标（通常编译生成可执行文件）</span></span><br><span class="line">make -j4  <span class="comment"># 并行编译（4线程，加快速度，j后接CPU核心数）</span></span><br><span class="line">make clean  <span class="comment"># 清理编译生成的目标文件、可执行文件等产物</span></span><br><span class="line">make all  <span class="comment"># 执行Makefile中all目标（编译所有产物）</span></span><br><span class="line">make <span class="built_in">test</span>  <span class="comment"># 执行Makefile中test目标（运行测试用例）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="C-C-编译：gcc-g">C/C++ 编译：gcc/g++</h2>
<p><code>gcc</code>是 C 语言编译器，<code>g++</code>是 C++ 编译器，支持编译、链接、生成动态库 / 静态库，可指定编译标准、链接第三方库等参数。</p>
<ul>
<li>
<p>基础用法：</p>
<ul>
<li><code>gcc [参数] 源文件 -o 可执行文件</code></li>
<li><code>g++ [参数] 源文件 -o 可执行文件</code></li>
</ul>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译C++程序（链接pthread线程库，指定C++17标准）</span></span><br><span class="line">g++ -o test_ol_ThreadPool test_ol_ThreadPool.cpp -lpthread -std=c++17</span><br><span class="line"><span class="comment"># 生成动态共享库（-shared：共享库，-fPIC：位置无关代码，-ldl：链接动态链接库）</span></span><br><span class="line">gcc -shared -fPIC -o libfile_hook.so file_hook.c -ldl</span><br><span class="line"><span class="comment"># 查看gcc版本</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 编译C程序生成可执行文件</span></span><br><span class="line">gcc -o test_unlink test_unlink.c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="系统资源监控：top">系统资源监控：top</h2>
<p><code>top</code>是交互式系统监控工具，实时显示进程的 CPU、内存、PID 等资源占用情况，支持排序、筛选、终止进程，是排查资源占用的核心工具。</p>
<ul>
<li>
<p>基础用法：<code>top</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top  <span class="comment"># 启动监控界面（默认按CPU占用降序）</span></span><br><span class="line"><span class="comment"># top界面常用操作：</span></span><br><span class="line"><span class="comment"># P：按CPU占用率排序 | M：按内存占用率排序</span></span><br><span class="line"><span class="comment"># 输入PID后按k，再输入9：强制终止指定进程</span></span><br><span class="line"><span class="comment"># q：退出top界面</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文本编辑：vi-vim">文本编辑：vi/vim</h2>
<p><code>vim</code>是<code>vi</code>的增强版文本编辑器，支持命令模式、插入模式、末行模式，是 Linux 无图形界面下的核心编辑工具。</p>
<ul>
<li>
<p>基础用法：<code>vim [文件名]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /proc/cpuinfo  <span class="comment"># 打开CPU信息文件查看/编辑</span></span><br><span class="line">vim /etc/vsftpd.conf  <span class="comment"># 编辑FTP服务配置文件</span></span><br><span class="line">vim file.txt  <span class="comment"># 打开当前目录的file.txt</span></span><br><span class="line"><span class="comment"># 核心操作：</span></span><br><span class="line"><span class="comment"># i：进入插入模式（输入内容） | Esc：退出插入模式</span></span><br><span class="line"><span class="comment"># :w：保存 | :q：退出 | :wq：保存并退出 | :q!：强制退出（放弃修改）</span></span><br><span class="line"><span class="comment"># /关键词：搜索关键词 | dd：删除当前行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看日历：cal">查看日历：cal</h2>
<p><code>cal</code>用于显示系统日历，默认显示当前月份，可指定年份 / 月份查看特定日历。</p>
<ul>
<li>
<p>基础用法：<code>cal [参数] [年份/月份]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cal  <span class="comment"># 显示当前月份日历</span></span><br><span class="line">cal 2025  <span class="comment"># 显示2025年全年日历</span></span><br><span class="line">cal 12 2025  <span class="comment"># 显示2025年12月日历</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="进程间通信-IPC-查看：ipcs">进程间通信 (IPC) 查看：ipcs</h2>
<p><code>ipcs</code>用于查看 Linux 系统中 IPC 资源（共享内存、信号量、消息队列），是排查 IPC 资源泄漏的核心工具。</p>
<ul>
<li>
<p>基础用法：<code>ipcs [参数]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs  <span class="comment"># 显示所有IPC资源</span></span><br><span class="line">ipcs -m  <span class="comment"># 仅显示共享内存</span></span><br><span class="line">ipcs -s  <span class="comment"># 仅显示信号量</span></span><br><span class="line">ipcs -q  <span class="comment"># 仅显示消息队列</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="进程间通信-IPC-删除：ipcrm">进程间通信 (IPC) 删除：ipcrm</h2>
<p><code>ipcrm</code>用于删除无用的 IPC 资源（共享内存、信号量、消息队列），释放系统资源。</p>
<ul>
<li>
<p>基础用法：<code>ipcrm [资源类型] [资源ID]</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcrm -m 0  <span class="comment"># 删除ID为0的共享内存（-m=共享内存）</span></span><br><span class="line">ipcrm -s 2  <span class="comment"># 删除ID为2的信号量（-s=信号量）</span></span><br><span class="line">ipcrm -q 5  <span class="comment"># 删除ID为5的消息队列（-q=消息队列）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="系统调用跟踪：strace">系统调用跟踪：strace</h2>
<p><code>strace</code>用于跟踪进程的系统调用和信号，可指定跟踪特定调用，是排查程序运行异常的核心工具。</p>
<ul>
<li>
<p>基础用法：<code>strace [参数] 命令</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跟踪ls命令的stat/open等系统调用</span></span><br><span class="line">strace -e trace=<span class="built_in">stat</span>,statat,lstat,open,openat /usr/bin/ls /tmp/protected.txt 2&gt;&amp;1</span><br><span class="line"><span class="comment"># 详细输出并保存跟踪结果到文件</span></span><br><span class="line">strace -v -o ls_trace.log /usr/bin/ls /tmp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="包管理（CentOS-RHEL）：yum">包管理（CentOS/RHEL）：yum</h2>
<p><code>yum</code>是 RHEL/CentOS 的包管理工具，自动解决依赖，用于安装 / 更新 / 卸载软件包。</p>
<ul>
<li>
<p>基础用法：<code>yum [参数] 操作 软件包名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y strace coreutils  <span class="comment"># 安装软件（-y：自动确认）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y ftp  <span class="comment"># 普通用户加sudo获取权限</span></span><br><span class="line">yum remove -y ftp  <span class="comment"># 卸载软件</span></span><br><span class="line">yum update -y  <span class="comment"># 更新所有软件包</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="包管理（Ubuntu-Debian）：apt-apt-get">包管理（Ubuntu/Debian）：apt/apt-get</h2>
<p><code>apt</code>（<code>apt-get</code>简化版）是 Ubuntu/Debian 的包管理工具，需先更新源再安装软件。</p>
<ul>
<li>
<p>基础用法：</p>
<ul>
<li><code>apt [参数] 操作 软件包名</code></li>
<li><code>apt-get [参数] 操作 软件包名</code></li>
</ul>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update  <span class="comment"># 更新软件源（必须先执行）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install ftp  <span class="comment"># 安装ftp</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install vsftpd  <span class="comment"># 安装FTP服务</span></span><br><span class="line"><span class="built_in">sudo</span> apt remove vsftpd  <span class="comment"># 卸载软件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="手册查询：man">手册查询：man</h2>
<p><code>man</code>用于查看命令 / 系统调用 / 函数的官方手册，不同章节对应不同类型文档（1 = 用户命令，2 = 系统调用，3 = 库函数）。</p>
<ul>
<li>
<p>基础用法：<code>man [章节] 命令/函数名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man <span class="built_in">read</span>  <span class="comment"># 查看read默认手册</span></span><br><span class="line">man 1 <span class="built_in">read</span>  <span class="comment"># 第1章（用户命令）的read手册</span></span><br><span class="line">man 2 <span class="built_in">read</span>  <span class="comment"># 第2章（系统调用）的read手册</span></span><br><span class="line">man memcmp  <span class="comment"># 查看memcmp库函数手册</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="环境变量删除：unset">环境变量删除：unset</h2>
<p><code>unset</code>用于删除已定义的环境变量，删除后变量立即失效。</p>
<ul>
<li>
<p>基础用法：<code>unset 变量名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> LD_PRELOAD  <span class="comment"># 删除动态库预加载变量</span></span><br><span class="line"><span class="built_in">unset</span> JAVA_HOME  <span class="comment"># 删除Java环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LD_PRELOAD</span>  <span class="comment"># 验证变量是否删除（无输出则成功）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看文件尾部：tail">查看文件尾部：tail</h2>
<p><code>tail</code>用于查看文件尾部内容，默认显示最后 10 行，<code>-f</code>可实时监控日志。</p>
<ul>
<li>
<p>基础用法：<code>tail [参数] 文件名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> /home/mysql/Projects/File_Protector/test/prot.txt  <span class="comment"># 显示最后10行</span></span><br><span class="line"><span class="built_in">tail</span> -n 20 /tmp/log.txt  <span class="comment"># 显示最后20行</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/vsftpd.log  <span class="comment"># 实时跟踪日志（Ctrl+C退出）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="目录树查看：tree">目录树查看：tree</h2>
<p><code>tree</code>以树形结构显示目录层级，直观展示文件 / 子目录，需先安装。</p>
<ul>
<li>
<p>基础用法：<code>tree [参数] 目录</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install tree -y  <span class="comment"># CentOS安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt install tree -y  <span class="comment"># Ubuntu安装</span></span><br><span class="line">tree  <span class="comment"># 查看当前目录树</span></span><br><span class="line">tree /home/mysql/Projects/File_Protector  <span class="comment"># 查看指定目录树</span></span><br><span class="line">tree -d /home/mysql/OL  <span class="comment"># 仅显示目录（不显示文件）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="DNS-解析：nslookup-getent">DNS 解析：nslookup/getent</h2>
<p><code>nslookup</code>查询域名 DNS 解析结果，<code>getent hosts</code>查询主机名 / IP 映射（优先 /etc/hosts）。</p>
<ul>
<li>
<p>基础用法：</p>
<ul>
<li><code>nslookup 域名/IP</code></li>
<li><code>getent hosts 域名/IP</code></li>
</ul>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup www.baidu.com  <span class="comment"># 查询百度DNS解析结果</span></span><br><span class="line">getent hosts www.baidu.com  <span class="comment"># 查询百度主机映射</span></span><br><span class="line">getent hosts 1.1.1.1  <span class="comment"># 反向查询IP对应的域名</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="网络连通性测试：ping">网络连通性测试：ping</h2>
<p><code>ping</code>基于 ICMP 协议测试主机连通性，默认持续发送数据包，Ctrl+C 终止。</p>
<ul>
<li>
<p>基础用法：<code>ping [参数] 目标IP/域名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com  <span class="comment"># 测试百度连通性</span></span><br><span class="line">ping -c 5 192.168.1.100  <span class="comment"># 发送5个数据包后停止</span></span><br><span class="line">ping -W 2 192.168.0.157  <span class="comment"># 超时2秒，测试内网主机</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="系统服务管理：systemctl">系统服务管理：systemctl</h2>
<p><code>systemctl</code>是 systemd 系统的服务管理工具，用于启动 / 停止 / 重启系统服务（如 vsftpd）。</p>
<ul>
<li>
<p>基础用法：<code>systemctl [操作] 服务名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart vsftpd  <span class="comment"># 重启FTP服务</span></span><br><span class="line">systemctl start vsftpd  <span class="comment"># 启动服务</span></span><br><span class="line">systemctl stop vsftpd  <span class="comment"># 停止服务</span></span><br><span class="line">systemctl status vsftpd  <span class="comment"># 查看服务状态</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="批量终止进程：pkill">批量终止进程：pkill</h2>
<p><code>pkill</code>根据进程名批量终止进程，无需手动查找 PID，比<code>kill</code>更便捷。</p>
<ul>
<li>
<p>基础用法：<code>pkill [参数] 进程名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill -9 File_Protector.exe  <span class="comment"># 强制终止所有该进程</span></span><br><span class="line">pkill -9 test_tcp_server  <span class="comment"># 终止包含该名称的进程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="创建-写入文件：echo">创建 / 写入文件：echo &gt;/&gt;&gt;</h2>
<p><code>echo</code>输出字符串，结合<code>&gt;</code>（覆盖）/<code>&gt;&gt;</code>（追加）可快速创建 / 修改文件。</p>
<ul>
<li>
<p>基础用法：<code>echo &quot;内容&quot; &gt; 文件名</code> 或 <code>echo &quot;内容&quot; &gt;&gt; 文件名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;我是受保护文件&quot;</span> &gt; /tmp/protected.txt  <span class="comment"># 创建并写入（覆盖原有内容）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;新增内容&quot;</span> &gt;&gt; /tmp/protected.txt  <span class="comment"># 追加内容到文件末尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /tmp/log.txt  <span class="comment"># 清空文件内容（保留文件）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="递归修改权限：chmod-R">递归修改权限：chmod -R</h2>
<p><code>chmod -R</code>递归修改目录及所有子文件 / 子目录的权限，适用于批量设置。</p>
<ul>
<li>
<p>基础用法：<code>chmod -R 权限 目录</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 777 .ssh  <span class="comment"># 递归设置.ssh目录为777权限</span></span><br><span class="line"><span class="built_in">chmod</span> -R 755 /home/mysql/Projects  <span class="comment"># 递归设置项目目录为755</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看目录本身权限：ls-ld">查看目录本身权限：ls -ld</h2>
<p><code>ls -ld</code>仅显示目录本身的权限 / 属性，而非目录内文件，常用于检查目录权限。</p>
<ul>
<li>
<p>基础用法：<code>ls -ld 目录名</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld .ssh  <span class="comment"># 查看.ssh目录本身权限</span></span><br><span class="line"><span class="built_in">ls</span> -ld /home/mysql/OL  <span class="comment"># 查看OL目录权限和所有者</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="动态库预加载：LD-PRELOAD">动态库预加载：LD_PRELOAD</h2>
<p><code>LD_PRELOAD</code>是 Linux 环境变量，指定优先加载的动态库，可覆盖系统默认库函数。</p>
<ul>
<li>
<p>基础用法：<code>export LD_PRELOAD=动态库路径</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=/home/mysql/Projects/File_Protector/4/libfile_protector.so</span><br><span class="line"><span class="comment"># 仅当前命令生效的预加载</span></span><br><span class="line">LD_PRELOAD=./libfile_hook.so /usr/bin/cat /tmp/protected.txt</span><br><span class="line"><span class="built_in">unset</span> LD_PRELOAD  <span class="comment"># 取消预加载</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看进程可执行路径：-proc-self-exe">查看进程可执行路径：/proc/self/exe</h2>
<p><code>/proc/self/exe</code>是指向当前进程可执行文件的符号链接，用于排查进程来源。</p>
<ul>
<li>
<p>基础用法：<code>ls -l /proc/self/exe</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /proc/self/exe  <span class="comment"># 查看当前Shell进程的可执行路径</span></span><br><span class="line"><span class="built_in">ls</span> -l /proc/1234/exe  <span class="comment"># 查看PID=1234进程的可执行路径</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="清空-删除目录：rm-rf">清空 / 删除目录：rm -rf</h2>
<p><code>rm -rf</code>递归强制删除目录及所有内容（无提示），需谨慎使用。</p>
<ul>
<li>
<p>基础用法：<code>rm -rf 目录名/文件</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /home/mysql/OL/build/*  <span class="comment"># 清空build目录（保留目录）</span></span><br><span class="line"><span class="built_in">rm</span> -rf /home/mysql/OL/build  <span class="comment"># 删除整个build目录</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="网络配置查看：ifconfig（补充-ipconfig）">网络配置查看：ifconfig（补充 ipconfig）</h2>
<p><code>ipconfig</code>是 Windows 命令，Linux 等价命令是<code>ifconfig</code>（需安装 net-tools），用于查看 / 配置网卡信息。</p>
<ul>
<li>
<p>基础用法：<code>ifconfig</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install net-tools -y  <span class="comment"># CentOS安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt install net-tools -y  <span class="comment"># Ubuntu安装</span></span><br><span class="line">ifconfig  <span class="comment"># 查看所有网卡信息</span></span><br><span class="line">ifconfig eth0  <span class="comment"># 查看eth0网卡信息</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看-CPU-信息：-proc-cpuinfo">查看 CPU 信息：/proc/cpuinfo</h2>
<p><code>/proc/cpuinfo</code>是伪文件，存储 CPU 硬件信息（核心数、型号等），通过<code>cat/vi</code>查看。</p>
<ul>
<li>
<p>基础用法：<code>cat /proc/cpuinfo</code> 或 <code>vi /proc/cpuinfo</code></p>
</li>
<li>
<p>常用示例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo  <span class="comment"># 查看所有CPU信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;model name&quot;</span> | <span class="built_in">uniq</span>  <span class="comment"># 筛选CPU型号</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;cpu cores&quot;</span> | <span class="built_in">uniq</span>  <span class="comment"># 筛选CPU核心数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文件搜索：find">文件搜索：find</h2>
<p><code>find</code>是 Linux 中功能强大的文件搜索工具，可根据文件属性（文件名、类型、大小、目录深度等）查找磁盘文件，通过指定对应参数即可实现精准搜索。</p>
<p>- 基础用法：<code>find 搜索路径 [搜索参数] 搜索条件</code></p>
<p>- 常用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 按文件名搜索（-name）：支持精确和模糊查询，模糊查询建议用引号包裹通配符</span></span><br><span class="line">find /root -name <span class="string">&quot;*.txt&quot;</span>  <span class="comment"># 模糊查询：搜索/root目录下后缀为txt的文件</span></span><br><span class="line">find /root -name <span class="string">&quot;onepiece.txt&quot;</span>  <span class="comment"># 精确查询：搜索/root目录下名为onepiece.txt的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 按文件类型搜索（-type）：常用类型字符：f(普通文件)、d(目录)、l(软链接)</span></span><br><span class="line">find /root -<span class="built_in">type</span> l  <span class="comment"># 搜索/root目录下的软链接文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 按文件大小搜索（-size）：单位：k(小写)、M(大写)、G(大写)；+大于、-小于、无符号则是区间(大小-1, 大小]</span></span><br><span class="line">find ./ -size +3M  <span class="comment"># 搜索当前目录下大于3M的文件</span></span><br><span class="line">find ./ -size -3M  <span class="comment"># 搜索当前目录下小于等于2M的文件（区间：[0M, 2M]）</span></span><br><span class="line">find ./ -size 3M   <span class="comment"># 搜索当前目录下2M~3M的文件（区间：(2M, 3M]）</span></span><br><span class="line">find ./ -size +1M -size -4M  <span class="comment"># 搜索当前目录下1M~3M的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 按目录层级搜索：-maxdepth(最多层级)、-mindepth(最少层级)，需配合其他条件使用</span></span><br><span class="line"><span class="built_in">sudo</span> find / -maxdepth 5 -name <span class="string">&quot;*.txt&quot;</span>  <span class="comment"># 从根目录开始，最多搜索5层，查找txt文件</span></span><br><span class="line"><span class="built_in">sudo</span> find / -mindepth 5 -name <span class="string">&quot;*.txt&quot;</span>  <span class="comment"># 从根目录开始，至少从第5层开始，查找txt文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 搜索后执行后续操作：exec(直接执行)、ok(交互式执行)、xargs(高效批量执行)</span></span><br><span class="line">find ./ -maxdepth 2 -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;  <span class="comment"># 查找2层内txt文件并查看详细信息</span></span><br><span class="line">find ./ -maxdepth 1 -name <span class="string">&quot;*.txt&quot;</span> -ok <span class="built_in">rm</span> -rf &#123;&#125; \;   <span class="comment"># 交互式删除1层内txt文件（需确认）</span></span><br><span class="line">find ./ -maxdepth 1 -name <span class="string">&quot;*.cpp&quot;</span> | xargs <span class="built_in">ls</span> -l      <span class="comment"># 用xargs批量查看1层内cpp文件详细信息</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">文件类型</th>
<th style="text-align:center">类型的字符描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通文件类型</td>
<td style="text-align:center">f</td>
</tr>
<tr>
<td style="text-align:center">目录类型</td>
<td style="text-align:center">d</td>
</tr>
<tr>
<td style="text-align:center">软连接类型</td>
<td style="text-align:center">l</td>
</tr>
<tr>
<td style="text-align:center">字符设备类型</td>
<td style="text-align:center">c</td>
</tr>
<tr>
<td style="text-align:center">块设备类型</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">管道类型</td>
<td style="text-align:center">p</td>
</tr>
<tr>
<td style="text-align:center">本地套接字类型</td>
<td style="text-align:center">s</td>
</tr>
</tbody>
</table>
<h2 id="字符串搜索：grep">字符串搜索：grep</h2>
<p><code>grep</code>用于查找文件中符合条件的字符串，支持递归搜索、忽略大小写、显示行号等功能，是文本内容检索的常用命令。搜索内容建议用引号包裹，避免特殊字符解析错误。</p>
<p>- 基础用法：<code>grep &quot;搜索内容&quot; 搜索路径/文件 [参数]</code></p>
<p>- 常用参数：</p>
<ul>
<li>-r：递归搜索目录下的所有文件</li>
<li>-i：忽略搜索内容的大小写</li>
<li>-n：显示匹配内容所在的行号</li>
</ul>
<p>- 常用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;include&quot;</span> a.c  <span class="comment"># 搜索a.c文件中是否包含&quot;include&quot;字符串</span></span><br><span class="line">grep <span class="string">&quot;INCLUDE&quot;</span> a.c -i  <span class="comment"># 忽略大小写，搜索a.c文件中的&quot;INCLUDE&quot;（含小写include）</span></span><br><span class="line">grep <span class="string">&quot;include&quot;</span> ./ -rn  <span class="comment"># 递归搜索当前目录下所有文件，显示含&quot;include&quot;的文件路径和行号</span></span><br></pre></td></tr></table></figure>
<h2 id="快速文件搜索：locate">快速文件搜索：locate</h2>
<p><code>locate</code>是简化版find，通过搜索本地文件数据库实现快速查找（效率远高于find），数据库默认每日自动更新，新增/修改文件后需用<code>updatedb</code>手动更新。</p>
<p>- 基础用法：<code>locate [参数] 搜索关键字</code></p>
<p>- 常用参数：</p>
<ul>
<li>-i：忽略文件名大小写</li>
<li>-n N：仅显示前N条匹配结果</li>
<li>-r：基于正则表达式匹配文件名</li>
</ul>
<p>- 常用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> updatedb  <span class="comment"># 手动更新文件数据库（普通用户需加sudo）</span></span><br><span class="line">locate <span class="built_in">test</span>  <span class="comment"># 搜索所有以&quot;test&quot;开头的文件</span></span><br><span class="line">locate /home/robin/test  <span class="comment"># 精确搜索/home/robin/目录下以&quot;test&quot;开头的文件</span></span><br><span class="line">locate TEST -i  <span class="comment"># 忽略大小写，搜索以&quot;TEST&quot;或&quot;test&quot;开头的文件</span></span><br><span class="line">locate <span class="built_in">test</span> -n 5  <span class="comment"># 搜索以&quot;test&quot;开头的文件，仅显示前5条结果</span></span><br><span class="line">locate -r <span class="string">&quot;\.cpp$&quot;</span>  <span class="comment"># 用正则表达式搜索以&quot;.cpp&quot;结尾的文件</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>测试</title>
    <url>/2025/11/04/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1>测试</h1>
<h2 id="测试技能">测试技能</h2>
<ul>
<li>功能测试</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801084757233.png" alt="image-20250801084757233"></p>
<ul>
<li>自动化测试</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801084941143.png" alt="image-20250801084941143"></p>
<ul>
<li>接口测试</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801085208846.png" alt="image-20250801085208846"></p>
<ul>
<li>性能测试</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801085633742.png" alt="image-20250801085633742"></p>
<ul>
<li>总结</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801085844545.png" alt="image-20250801085844545"></p>
<h2 id="测试分类">测试分类</h2>
<ul>
<li>按测试阶段划分</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801090231283.png" alt="image-20250801090231283"></p>
<ul>
<li>按代码可见度划分</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801090402050.png" alt="image-20250801090402050"></p>
<ul>
<li>总结</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801090613161.png" alt="image-20250801090613161"></p>
<h2 id="模型">模型</h2>
<ul>
<li>质量模型</li>
</ul>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801090813574.png" alt="image-20250801090813574"></p>
<h2 id="测试流程">测试流程</h2>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801091247408.png" alt="image-20250801091247408"></p>
<h2 id="测试用例">测试用例</h2>
<h3 id="一、什么是用例">一、什么是用例</h3>
<p>广义的 “用例”，是为达成某个特定目标、场景而设计的一系列操作步骤、条件及预期结果的集合，可应用于不同领域。像业务流程梳理里，用于描述用户办理业务的流程步骤；在软件测试场景中，聚焦软件功能验证，进而延伸出 “测试用例” 。简单来说，它是一种规范化、结构化描述 “怎么做以及期望怎样” 的文档或概念 。</p>
<h3 id="二、什么是测试用例">二、什么是测试用例</h3>
<p>在软件测试领域，测试用例是<strong>为验证软件某一功能（或特性）、模块，预先设计的详细测试方案</strong> ，包含输入数据、操作步骤、预设环境、预期结果等要素 。比如测试电商 App 购物车 “添加商品” 功能，测试用例要写清：在登录状态、网络正常环境下，点击商品详情页 “加入购物车” 按钮（操作），输入商品数量（如 1 件，输入数据 ），预期购物车数量更新、商品信息正确显示（预期结果 ） 。通过这种精准设计，覆盖软件功能验证点，找出潜在缺陷 。</p>
<h3 id="三、用例的作用">三、用例的作用</h3>
<ol>
<li><strong>指导测试执行</strong>：测试人员按用例步骤、数据操作，避免测试遗漏、随意性，让测试过程标准化 。</li>
<li><strong>发现软件缺陷</strong>：清晰的输入、预期结果对比，能快速识别实际结果与预期不符的情况，精准定位问题 。</li>
<li><strong>评估测试覆盖率</strong>：通过梳理用例覆盖的功能点、场景，判断是否覆盖软件需求（如功能需求、非功能需求 ），评估测试完整性 。</li>
<li><strong>回归测试依据</strong>：软件迭代更新后，复用历史用例执行回归测试，验证修改是否引入新问题、原有功能是否正常 。</li>
<li><strong>团队协作与知识传承</strong>：用例是需求、测试、开发沟通的 “共同语言” ，新成员也能通过用例快速了解测试重点 。</li>
</ol>
<h3 id="四、用例编写格式（常用模板，可灵活调整-）">四、用例编写格式（常用模板，可灵活调整 ）</h3>
<table>
<thead>
<tr>
<th>用例编号</th>
<th>测试模块 / 功能</th>
<th>测试标题</th>
<th>前置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>实际结果</th>
<th>测试人员</th>
<th>测试时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>TC-001</td>
<td>电商 App - 购物车</td>
<td>验证添加商品到购物车功能</td>
<td>1. 手机已安装目标 App 2. 用户已登录 3. 网络连接正常</td>
<td>1. 打开 App，进入商品详情页（如某款手机详情 ） 2. 点击 “加入购物车” 按钮 3. 在购物车弹窗，输入购买数量（如 2 台 ），点击 “确认”</td>
<td>1. 购物车页面数量显示为 2 2. 商品名称、价格、数量与选择一致 3. 底部 “去结算” 按钮可点击</td>
<td>待测试执行后填写</td>
<td>[测试人员姓名]</td>
<td>[具体日期，如 2025-08-01]</td>
</tr>
</tbody>
</table>
<h4 id="说明：">说明：</h4>
<ul>
<li><strong>用例编号</strong>：唯一标识，方便管理、检索，如按模块 + 序号规则（TC 代表 Test Case ）。</li>
<li><strong>测试模块 / 功能</strong>：明确归属，便于分类、筛选。</li>
<li><strong>测试标题</strong>：简洁概括测试点（如 “验证登录功能 - 密码错误提示” ）。</li>
<li><strong>前置条件</strong>：执行用例前需满足的环境、状态（如登录状态、网络要求、数据准备 ）。</li>
<li><strong>测试步骤</strong>：清晰、有序的操作流程，步骤要具体可执行 。</li>
<li><strong>预期结果</strong>：基于需求，明确、可验证的期望输出（不能模糊，要量化、精准 ）。</li>
<li><strong>实际结果</strong>：测试执行后填写，对比预期判断是否通过 。</li>
<li><strong>测试人员 &amp; 时间</strong>：记录执行信息，方便追溯 。</li>
</ul>
<h2 id="划分测试点">划分测试点</h2>
<h3 id="一、等价类划分法">一、等价类划分法</h3>
<h4 id="（一）核心思想">（一）核心思想</h4>
<p>将输入数据（或操作场景）划分为若干 <strong>“等价类”</strong>，每个等价类内的测试数据具有相同测试效果。只需选取**代表性数据 ** 测试，即可覆盖该类所有情况，减少用例数量。</p>
<h4 id="（二）示例（以-“年龄输入框，要求-18-60-岁”-为例）">（二）示例（以 “年龄输入框，要求 18 - 60 岁” 为例）</h4>
<ul>
<li>
<p><strong>有效等价类</strong>：18≤年龄≤60（如 <code>25 岁</code>、<code>40 岁</code> ）</p>
</li>
<li>
<p>无效等价类：</p>
<ul>
<li>年龄 &lt; 18（如 <code>15 岁</code> ）</li>
<li>年龄 &gt; 60（如 <code>65 岁</code> ）</li>
<li>非数字（如 <code>“abc”</code> ）</li>
</ul>
</li>
</ul>
<p>测试时，从每个等价类选 1 - 2 个数据验证，即可覆盖该类逻辑。</p>
<h4 id="（三）作用">（三）作用</h4>
<ol>
<li>
<p>大幅减少测试用例数量，避免冗余测试。</p>
</li>
<li>
<p>聚焦关键边界与规则，优先覆盖核心逻辑。</p>
</li>
</ol>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801092840256.png" alt="image-20250801092840256"></p>
<hr>
<h3 id="二、边界值分析法">二、边界值分析法</h3>
<h4 id="（一）核心思想-2">（一）核心思想</h4>
<p>软件对 <strong>“边界值”</strong>（如输入范围的最小值、最大值、临界值 ）更敏感，易出现缺陷。专门针对**边界点及附近值 ** 设计用例，补充等价类划分法的不足。</p>
<h4 id="（二）示例（以-“密码长度-6-16-位”-为例）">（二）示例（以 “密码长度 6 - 16 位” 为例）</h4>
<ul>
<li><strong>边界值</strong>：<code>6 位</code>、<code>7 位</code>、<code>15 位</code>、<code>16 位</code></li>
<li><strong>边界附近值</strong>：<code>5 位</code>（比最小少 1 ）、<code>17 位</code>（比最大多 1 ）</li>
</ul>
<p>通过验证这些值，暴露 “边界处理逻辑漏洞”（如 6 位密码是否真的能通过，17 位是否被拦截 ）。</p>
<h4 id="（三）作用-2">（三）作用</h4>
<ol>
<li>
<p>精准打击 <strong>“边界漏洞”</strong>（这类问题在实际场景中高频出现，如数组越界、长度限制失效 ）。</p>
</li>
<li>
<p>补充等价类划分法（等价类侧重 “区间覆盖”，边界值侧重 “临界点” ）。</p>
</li>
</ol>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801093843614.png" alt="image-20250801093843614"></p>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801094411878.png" alt="image-20250801094411878"></p>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801095505951.png" alt="image-20250801095505951"></p>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801095757184.png" alt="image-20250801095757184"></p>
<hr>
<h3 id="三、判定表法">三、判定表法</h3>
<h4 id="（一）核心思想-3">（一）核心思想</h4>
<p>当测试场景存在<strong>多个输入条件组合</strong>，且不同组合对应不同输出时，用 <strong>“判定表（表格）”</strong> 梳理所有条件组合及结果，再转化为测试用例。</p>
<h4 id="（二）示例（以-“电商订单提交”-为例）">（二）示例（以 “电商订单提交” 为例）</h4>
<table>
<thead>
<tr>
<th>条件 1：库存是否充足</th>
<th>条件 2：地址是否填写</th>
<th>条件 3：支付方式是否可选</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>是</td>
<td>提交成功</td>
</tr>
<tr>
<td>是</td>
<td>是</td>
<td>否</td>
<td>提示 “支付方式不可用”</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td>是</td>
<td>提示 “地址未填写”</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td>否</td>
<td>提示 “地址未填写”</td>
</tr>
<tr>
<td>否</td>
<td>是</td>
<td>是</td>
<td>提示 “库存不足”</td>
</tr>
<tr>
<td>否</td>
<td>是</td>
<td>否</td>
<td>提示 “库存不足”</td>
</tr>
<tr>
<td>否</td>
<td>否</td>
<td>是</td>
<td>提示 “库存不足、地址未填”</td>
</tr>
<tr>
<td>否</td>
<td>否</td>
<td>否</td>
<td>提示 “库存不足、地址未填”</td>
</tr>
</tbody>
</table>
<h4 id="（三）作用-3">（三）作用</h4>
<ol>
<li>
<p>解决 <strong>“多条件组合”</strong> 的复杂场景，避免遗漏关键组合。</p>
</li>
<li>
<p>让测试逻辑可视化，方便评审与维护。</p>
</li>
</ol>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801100712535.png" alt="image-20250801100712535"></p>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801100742461.png" alt="image-20250801100742461"></p>
<p><img src="/2025/11/04/%E6%B5%8B%E8%AF%95/image-20250801100901439.png" alt="image-20250801100901439"></p>
<hr>
<h3 id="四、场景法">四、场景法</h3>
<h4 id="（一）核心思想-4">（一）核心思想</h4>
<p>模拟用户<strong>实际使用流程（场景）</strong> ，覆盖<strong>正常流程</strong>和<strong>异常分支</strong>，验证软件在完整业务链路中的表现。</p>
<h4 id="（二）示例（以-“打车-App-流程”-为例）">（二）示例（以 “打车 App 流程” 为例）</h4>
<ul>
<li>
<p><strong>正常场景</strong>：<br>
下单 → 司机接单 → 开始行程 → 结束行程 → 支付</p>
</li>
<li>
<p>异常场景：</p>
<ul>
<li>下单后取消订单</li>
<li>司机拒单后重新分配</li>
<li>支付失败重试</li>
</ul>
</li>
</ul>
<h4 id="（三）作用-4">（三）作用</h4>
<ol>
<li>贴近用户真实行为，确保 <strong>“业务流程完整可用”</strong>。</li>
<li>覆盖前端交互、后端逻辑联动的复杂场景，暴露 “流程断裂” 类问题（如取消订单后无法重新下单 ）。</li>
</ol>
<hr>
<h3 id="五、错误推测法">五、错误推测法</h3>
<h4 id="（一）核心思想-5">（一）核心思想</h4>
<p>基于<strong>经验、历史缺陷、行业常见问题</strong>，“推测” 软件可能出现的错误场景，针对性设计用例。无固定流程，依赖测试人员经验。</p>
<h4 id="（二）示例（以-“文件上传功能”-为例）">（二）示例（以 “文件上传功能” 为例）</h4>
<p>根据经验推测以下场景：</p>
<ul>
<li>文件格式错误（如要求 PDF，传 PNG ）</li>
<li>文件过大（超过系统限制 ）</li>
<li>网络中断时上传</li>
</ul>
<h4 id="（三）作用-5">（三）作用</h4>
<ol>
<li>补充 <strong>“结构化方法（如等价类、判定表 ）”</strong> 的不足，覆盖经验性、隐蔽性问题。</li>
<li>适合敏捷测试、探索性测试，快速挖掘潜在风险。</li>
</ol>
<hr>
<h3 id="六、综合案例（以-“登录功能-账号密码登录”-为例）">六、综合案例（以 “登录功能 - 账号密码登录” 为例）</h3>
<p>以下是结合多种方法设计的用例思路：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>设计思路 &amp; 用例示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>等价类划分</td>
<td>- 有效类：正确账号 + 正确密码 - 无效类：错误账号、错误密码、空账号 / 密码</td>
</tr>
<tr>
<td>边界值分析</td>
<td>密码长度边界（如要求 6 - 20 位：测 <code>5 位</code>、<code>6 位</code>、<code>20 位</code>、<code>21 位</code> ）</td>
</tr>
<tr>
<td>判定表法</td>
<td>条件：账号存在（是 / 否）、密码正确（是 / 否） 结果：登录成功、提示账号不存在、密码错误</td>
</tr>
<tr>
<td>场景法</td>
<td>- 正常场景：输入正确信息 → 登录成功 → 跳转首页 - 异常场景：输错密码后重试、登录中网络断开</td>
</tr>
<tr>
<td>错误推测法</td>
<td>模拟 “账号被锁定后登录”“密码含特殊字符（如 <code>&amp;*</code> ）” 等经验性场景</td>
</tr>
</tbody>
</table>
<p>这些方法可<strong>单独或组合使用</strong>，目标是用<strong>最少用例覆盖最多风险</strong>，提升测试效率与质量。实际项目中，需根据需求复杂度、业务场景灵活搭配 。</p>
<h2 id="测试工具推荐">测试工具推荐</h2>
<ol>
<li>
<p><strong>缺陷管理工具</strong>：禅道，JIRA，TFS</p>
</li>
<li>
<p><strong>功能测试工具</strong>：Selenium</p>
</li>
<li>
<p><strong>性能测试工具</strong>： JMeter</p>
</li>
<li>
<p><strong>单元测试工具</strong>： JUnit、TestNG</p>
</li>
<li>
<p><strong>集成测试工具</strong>：Spring Test</p>
</li>
<li>
<p><strong>接口测试工具</strong>：RestAssured</p>
</li>
<li>
<p><strong>UI 测试工具</strong>：Selenium、Appium</p>
</li>
<li>
<p><strong>内存泄露测试工具</strong>：jmap、jconsole、jvisualvm</p>
</li>
</ol>
]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM 使用教学</title>
    <url>/2025/12/07/VIM%20%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<h1><font style=background:#FFFDF6 color="DarkGoldenRod">VIM使用教学</font></h1>
<p><font style=background:#FFFDF6 color="DarkGoldenRod"><strong>作者: ol</strong></font><br>
<font style=background:#FFFDF6 color="DarkGoldenRod"> ⚠著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</font></p>
<blockquote>
<p><font style=background:#EBFAF3 color="green">💡参考：</font><br>
<font style=background:#EBFAF3 color="green"><a href="https://subingwen.cn/linux/vim/#3-10-%E6%9F%A5%E7%9C%8Bman%E6%96%87%E6%A1%A3">爱编程的大丙</a></font><br>
<font style=background:#EBFAF3 color="green"><a href="https://www.bilibili.com/video/BV13t4y1t7Wg/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=000ae0f5bb7431ae6ed83b1d70da6810">技术蛋老师</a></font><br>
<font style=background:#EBFAF3 color="green"><a href="https://www.bilibili.com/video/BV1rT411Y7un/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=000ae0f5bb7431ae6ed83b1d70da6810">皮哥Bryant</a></font></p>
</blockquote>
<h2 id="font-style-background-EBFAF3-color-green-正常模式（NORMAL）-font"><font style=background:#EBFAF3 color="green">正常模式（NORMAL）</font></h2>
<p>按 <strong>Esc</strong> 进入正常模式</p>
<h3 id="光标移动">光标移动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标准的移动光标的方法: 使用 h, j, k, l</span></span><br><span class="line"></span><br><span class="line">                                        光标上移   </span><br><span class="line">                                           ↑</span><br><span class="line">                                           |</span><br><span class="line">                     光标左移 &lt;-- h    j    k    l --&gt; 光标右移</span><br><span class="line">                                      |</span><br><span class="line">                                      ↓</span><br><span class="line">                                   光标下移    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">j 可以想象为 Jack（小丑）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k 可以想象为 King（国王）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">King肯定比Jack要高高在上嘛，所以k上j下</span></span><br></pre></td></tr></table></figure>
<h3 id="光标移动命令">光标移动命令</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">光标移动到行首</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">光标移动到行尾部</td>
<td style="text-align:center">选按两个键: shift + 4</td>
</tr>
<tr>
<td style="text-align:center">gg</td>
<td style="text-align:center">光标移动到文件头</td>
<td style="text-align:center">第一行的开始</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">光标移动到文件尾部</td>
<td style="text-align:center">最后一行的开始</td>
</tr>
<tr>
<td style="text-align:center">数字n+G</td>
<td style="text-align:center">行跳转</td>
<td style="text-align:center">n 代表要跳转到哪一行</td>
</tr>
<tr>
<td style="text-align:center">数字n+回车</td>
<td style="text-align:center">相对跳转 n 行</td>
<td style="text-align:center">从光标所在当前行往下跳 n 行, n 对应的是一个整数</td>
</tr>
<tr>
<td style="text-align:center">数字n+j</td>
<td style="text-align:center">相对向下跳转 n 行</td>
<td style="text-align:center">从光标所在当前行往下跳 n 行, n 对应的是一个整数，不需要回车</td>
</tr>
<tr>
<td style="text-align:center">数字n+k</td>
<td style="text-align:center">相对向上跳转 n 行</td>
<td style="text-align:center">从光标所在当前行往上跳 n 行, n 对应的是一个整数，不需要回车</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">光标按单词移动，移动到下一个单词首部</td>
<td style="text-align:center">w代表word</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">光标按单词移动，移动到下一个单词尾部</td>
<td style="text-align:center">e代表end</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">光标按单词移动，移动到上一个单词首部</td>
<td style="text-align:center">b代表back</td>
</tr>
</tbody>
</table>
<h3 id="删除命令">删除命令</h3>
<p>在vim中是没有删除操作的, 其实所谓的删除就是剪切, 被删除的数据都可被粘贴到文档的任意位置, 即便如此我们还是习惯性的将剪切操作称之为删除, 常用的删除操作如下表所示:</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x (小写)</td>
<td style="text-align:center">删除光标后边的字符</td>
<td style="text-align:center">vim中的光标比较宽会盖住后边的字符</td>
</tr>
<tr>
<td style="text-align:center">X (大写)</td>
<td style="text-align:center">删除光标前边的字符</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">dw</td>
<td style="text-align:center">删除单词</td>
<td style="text-align:center">dw表示delete a word，要先把光标移动到单词的第一个字母上再删除, 否则单词只能被删除一部分</td>
</tr>
<tr>
<td style="text-align:center">cw</td>
<td style="text-align:center">删除单词并进入编辑模式</td>
<td style="text-align:center">cw表示change a word，要先把光标移动到单词的第一个字母上再删除, 否则单词只能被删除一部分</td>
</tr>
<tr>
<td style="text-align:center">ci（(,[,}）或ci（),],}）</td>
<td style="text-align:center">删除()或[]或{}里的内容并进入编辑模式</td>
<td style="text-align:center">ci表示change in</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">删除字母并进入编辑模式</td>
<td style="text-align:center">只删除一个字母，并进入编辑模式，光标在删除的单词前</td>
</tr>
<tr>
<td style="text-align:center">d0</td>
<td style="text-align:center">删除光标前的字符串</td>
<td style="text-align:center">从字符串开头到光标当前位置的字符串被删除了</td>
</tr>
<tr>
<td style="text-align:center">d$ (D)</td>
<td style="text-align:center">删除光标后的字符串</td>
<td style="text-align:center">从光标当前位置到字符串尾部的字符串被删除了, 使用 D也行</td>
</tr>
<tr>
<td style="text-align:center">dd</td>
<td style="text-align:center">删除光标所在行</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">ndd</td>
<td style="text-align:center">删除n行</td>
<td style="text-align:center">从光标所在行开始删除n行, n对应的是一个整数</td>
</tr>
</tbody>
</table>
<h3 id="撤销和反撤销">撤销和反撤销</h3>
<p>撤销和反撤销对应windows中的 ctrl+z和ctrl+y, 但是在vim中使用这两个快捷键是不行的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">撤销</td>
<td style="text-align:center">u表示undo，等价于 windows 中的 ctrl+z</td>
</tr>
<tr>
<td style="text-align:center">ctrl+r</td>
<td style="text-align:center">反撤销</td>
<td style="text-align:center">r表示redo，等价于 windows 中的 ctrl+y</td>
</tr>
</tbody>
</table>
<h3 id="复制和粘贴">复制和粘贴</h3>
<p>在vim中做删除操作就相当于剪切, 剪切或者复制之后的数据都可以用来做粘贴操作, 在vim中对应的快捷键如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">粘贴到光标所在行的下边</td>
<td style="text-align:center">p表示paste(粘贴)，小写的 p</td>
</tr>
<tr>
<td style="text-align:center">数字n+p</td>
<td style="text-align:center">粘贴到光标所在行的下边，n份</td>
<td style="text-align:center">n是整数，小写的 p</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">粘贴到光标所在行的上边</td>
<td style="text-align:center">大写的 P</td>
</tr>
<tr>
<td style="text-align:center">yy</td>
<td style="text-align:center">复制光标所在行</td>
<td style="text-align:center">y表示yank(猛拉)</td>
</tr>
<tr>
<td style="text-align:center">数字n+yy</td>
<td style="text-align:center">从光标所在行向下复制 n 行</td>
<td style="text-align:center">n是要复制的行数, 代表一个整数</td>
</tr>
<tr>
<td style="text-align:center">yw</td>
<td style="text-align:center">复制光标所在的单词</td>
<td style="text-align:center">yw表示yank a word</td>
</tr>
</tbody>
</table>
<h3 id="重复操作">重复操作</h3>
<p>vim会自动记录你上次的操作，.可以执行上一次操作，在vim中对应的快捷键如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">执行上一次操作</td>
<td style="text-align:center">.(英语的句号)</td>
</tr>
</tbody>
</table>
<h3 id="注释">注释</h3>
<p>vim可以直接注释单行和多行以及块，在vim中对应的快捷键如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">gcc</td>
<td style="text-align:center">注释单行</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">gc+数字n+j</td>
<td style="text-align:center">此行+向下注释n行</td>
<td style="text-align:center">总注释n+1行</td>
</tr>
<tr>
<td style="text-align:center">gc+数字n+k</td>
<td style="text-align:center">此行+向上注释n行</td>
<td style="text-align:center">总注释n+1行</td>
</tr>
<tr>
<td style="text-align:center">gc+（(,[,{,},],)）</td>
<td style="text-align:center">注释一个块</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
<h2 id="font-style-background-EBFAF3-color-green-编辑模式（INSERT）-font"><font style=background:#EBFAF3 color="green">编辑模式（INSERT）</font></h2>
<p>按 <strong>i 或 Ins</strong> 进入编辑模式</p>
<h3 id="切换到编辑模式">切换到编辑模式</h3>
<p>如果要编辑文件, 需要从命令模式切换到文件编辑模式, 切换模式的快捷键有很多, 不同的快捷键对应的效果有所不同, 效果如下表所示:</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">i代表insert，从光标前边开始输入</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">a代表append，从光标的后边开始输入</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">o代表open a new line，在光标下边创建新行, 在新行中输入</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">删除光标后边的字符(盖住的字符), 从删除的字符位置开始输入</td>
</tr>
<tr>
<td style="text-align:center">I (大写的i)</td>
<td style="text-align:center">从当前行行首开始输入</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">从当前行行尾开始输入</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">在光标上边创建新行, 在新行中输入</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">删除当前行, 在当前行开始输入</td>
</tr>
<tr>
<td style="text-align:center">cw</td>
<td style="text-align:center">删除单词, 在当前行开始输入</td>
</tr>
<tr>
<td style="text-align:center">ci（(,[,}）或ci（),],}）</td>
<td style="text-align:center">删除()或[]或{}里的内容, 在当前行开始输入</td>
</tr>
</tbody>
</table>
<p><font style=background:#EBFAF3 color="green">💡文件编辑完成之后, 从编辑模式回到命令模式只需要按键盘上的Esc即可。</font></p>
<p><img src="/2025/12/07/VIM%20%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/%E8%BD%AC%E4%B8%BA%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.png" alt="转为编辑模式插入位置"></p>
<h2 id="font-style-background-EBFAF3-color-green-命令模式（COMMAND）-font"><font style=background:#EBFAF3 color="green">命令模式（COMMAND）</font></h2>
<h3 id="保存退出">保存退出</h3>
<p>使用vim对文件编辑完成之后, 需要保存或者退出vim一般都是在末行模式下完成的, 不管是进行那种操作都有对应的操作命令, 如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">退出, 如果退出的时候文件没有保存, vim会提示是否要保存</td>
</tr>
<tr>
<td style="text-align:center">q!</td>
<td style="text-align:center">直接退出, 不保存 (强制退出)</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">保存, 不退出 (相当在windows中于按了ctrl+s)</td>
</tr>
<tr>
<td style="text-align:center">wq</td>
<td style="text-align:center">保存退出</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">保存退出</td>
</tr>
</tbody>
</table>
<h3 id="替换">替换</h3>
<p>命令模式下的替换比正常模式下的替换功能要强大的多, 在命令模式下可以指定将什么样的内容替换为什么样的内容, 并且可以指定替换某一行或者某几行或者是全文替换。</p>
<p>替换对应的命令是 s 并且可以给其指定参数，默认情况下只替换相关行的第一个满足条件的关键字， 如果需要整行替换需要加参数/g。</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s/被替换的关键字/新的关键字/g</td>
<td style="text-align:center">g表示global全局替换，只对光标所在行进行替换</td>
</tr>
<tr>
<td style="text-align:center">行号1, 行号2s/被替换的关键字/新的关键字/g</td>
<td style="text-align:center">[行号1 , 行号2] 是一个从小到大的范围, 对这个范围进行替换</td>
</tr>
<tr>
<td style="text-align:center">%s/被替换的关键字/新的关键字/g</td>
<td style="text-align:center">%代表对所有行进行替换</td>
</tr>
</tbody>
</table>
<h3 id="查找">查找</h3>
<p>在vim的命令模式下一共有三种查找方式, 首先需要在键盘上输入对应的字符, 然后按回车键vim会进行关键字匹配, 之后就可以通过 n 或者N 进行关键字之间的切换了。</p>
<table>
<thead>
<tr>
<th style="text-align:center">搜索快捷键</th>
<th style="text-align:center">关键字遍历</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">n</td>
<td style="text-align:center">从当前位置向下</td>
<td style="text-align:center">直接按键盘上的 /即可</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">N</td>
<td style="text-align:center">从当前位置向上</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">n</td>
<td style="text-align:center">从当前位置向上</td>
<td style="text-align:center">直接按键盘上的 ?即可, 需要使用组合键</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">N</td>
<td style="text-align:center">从当前位置向下</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:center">n</td>
<td style="text-align:center">从当前位置向上</td>
<td style="text-align:center">光标需要先放在被搜索的关键字上, 键盘上按 #</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">N</td>
<td style="text-align:center">从当前位置向下</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p><font style=background:#EBFAF3 color="green">💡关于 ? 和 # 都需要使用组合键, 这点要注意一下。</font></p>
<p><font style=background:#EBFAF3 color="green">下面总结一下这三种搜索方式：</font></p>
<ul>
<li><font style=background:#EBFAF3 color="green"> 使用 / 或者 ? 搜索效果一样, 只是遍历关键字的时候的顺序是相反的</font></li>
<li><font style=background:#EBFAF3 color="green">使用 # 必须先从被搜索的文件中找到要搜索的关键字, 好处就是搜索的内容不需要通过键盘输入</font></li>
<li><font style=background:#EBFAF3 color="green">以上两种搜索方式各有优劣, 请根据实际情况选择使用。</font></li>
</ul>
<h2 id="font-style-background-EBFAF3-color-green-视图模式（VISUAL）-font"><font style=background:#EBFAF3 color="green">视图模式（VISUAL）</font></h2>
<p>在编辑文件的过程中, 有时候需要删除或者需要复制的数据不整行的, 而是一行中的某一部分, 这时候可以使用可视模式进行文本的选择, 之后再通过相关的快捷键对所选中的数据块进行复制或者删除操作。</p>
<p>有三种方式可以切换到可视模式:</p>
<ul>
<li>v： 进入的字符可视化模式（Characterwise visual mode)，文本选择是以字符为单位的。</li>
<li>V ：进入的行可视化模式（Linewise visual mode)，文本选择是以行为单位的。</li>
<li>ctrl-v： 进入的块可视化模式（Blockwise visual mode），可以选择一个矩形内的文本。</li>
</ul>
<p><strong>进入到可视模式之后，就可以进行文本块的选择和复制以及删除了</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">光标向左移动</td>
<td style="text-align:center">移动光标用于可视模式下的数据块选择</td>
</tr>
<tr>
<td style="text-align:center">j</td>
<td style="text-align:center">光标向下移动</td>
<td style="text-align:center">移动光标用于可视模式下的数据块选择</td>
</tr>
<tr>
<td style="text-align:center">k</td>
<td style="text-align:center">光标向上移动</td>
<td style="text-align:center">移动光标用于可视模式下的数据块选择</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">光标向右移动</td>
<td style="text-align:center">移动光标用于可视模式下的数据块选择</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">删除(剪切)</td>
<td style="text-align:center">删除可视模式下选中的数据块</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">复制可视模式下选中的数据块</td>
</tr>
<tr>
<td style="text-align:center">p (小写)</td>
<td style="text-align:center">数据粘贴到光标的后边</td>
<td style="text-align:center">粘贴在可视模式下复制或者剪切的数据块</td>
</tr>
<tr>
<td style="text-align:center">P (大写)</td>
<td style="text-align:center">数据粘贴到光标的前边</td>
<td style="text-align:center">粘贴在可视模式下复制或者剪切的数据块</td>
</tr>
</tbody>
</table>
<h3 id="字符可视模式">字符可视模式</h3>
<p>控制光标方向用来选择文件中的不规则数据块, 可以对选中的文本信息进行复制和删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到字符可视模式，直接在键盘上按 v 即可:</span> </span><br><span class="line">v</span><br></pre></td></tr></table></figure>
<p>通过 v 切换到字符可视模式之后， 在窗口的最下方会看到 – VISUAL-- 字样。</p>
<h3 id="行可视模式">行可视模式</h3>
<p>向下移动光标可以选择一整行, 向上移动光标可以取消整行选择</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入行可视模式, 键盘上按 <span class="built_in">shift</span>+v</span> </span><br><span class="line">V</span><br></pre></td></tr></table></figure>
<p>通过 V 切换到行可视模式之后， 在窗口的最下方会看到 – VISUAL LINE – 字样。</p>
<h3 id="块可视化模式">块可视化模式</h3>
<p>通过向上，下移动光标控制矩形文本块的高度，通过向左，右移动光标控制矩形文本块的宽度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入块可视模式, 选择一个矩形文本块</span></span><br><span class="line">ctrl+v</span><br></pre></td></tr></table></figure>
<p>通过 ctrl+v 切换到块可视模式之后， 在窗口的最下方会看到 – VISUAL BLOCK – 字样。</p>
<h2 id="font-style-background-EBFAF3-color-green-VIM配置文件-font"><font style=background:#EBFAF3 color="green">VIM配置文件</font></h2>
<p>vim 是一个文本编辑器工具, 这个工具也是有配置文件的，文件的名字叫做vimrc，在里边可以设置样式，功能, 快捷键等属性 。对应的配置文件分为两种 用户级别和系统级别。</p>
<ul>
<li>用户级别的配置文件（~/.vimrc）只对当前用户有效</li>
<li>系统级别的配置文件（/ect/vim/vimrc）对所有Linux用户都有效</li>
<li>如果两个配置文件都设置了, 用户级别的配置文件起作用（用户级别优先级高）。</li>
</ul>
]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>VIM - Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OL</title>
    <url>/2025/12/19/OL/</url>
    <content><![CDATA[<h1>OL</h1>
<p>一个包含 <code>ollib</code>（含<strong>主从 Reactor 多线程网络库</strong>）、<code>oldblib</code>（MySQL/Oracle 数据库交互）及 FTP 功能的 C++ 工具库，提供基础功能、多数据库交互、FTP 客户端支持及 Linux 专属的高性能网络通信能力。</p>
<p><strong>项目地址</strong>：<a href="https://github.com/1613661434/OL">https://github.com/1613661434/OL</a></p>
<h2 id="📜-许可证信息">📜 许可证信息</h2>
<p><img src="https://img.shields.io/badge/License-CC%20BY%204.0-blue.svg" alt="License: CC BY 4.0"></p>
<p>本项目所有代码（含基础功能、网络库、数据库交互模块、FTP 客户端模块及内置依赖）均以 <strong>Creative Commons Attribution 4.0 International (CC BY 4.0)</strong> 许可证发布，完整法律文本见 <a href="https://creativecommons.org/licenses/by/4.0/legalcode">CC BY 4.0 官方协议</a>。</p>
<h3 id="CC-BY-4-0-核心条款（通俗解读）">CC BY 4.0 核心条款（通俗解读）</h3>
<p>你可以<strong>自由地</strong>：</p>
<ul>
<li>
<p><strong>共享</strong>：以任何媒介 / 格式复制、分发本项目代码或文档（包括商业用途）；</p>
</li>
<li>
<p><strong>改编</strong>：对代码进行修改、扩展、集成到其他项目（包括商业项目），无需额外申请授权。</p>
</li>
</ul>
<p>需遵守的<strong>唯一核心义务</strong>：</p>
<ul>
<li><strong>署名（Attribution）</strong>：使用或分发本项目代码 / 衍生作品时，需注明本项目来源（格式建议：“基于 ol 木子李 lo 开发的 OL 库”），并提供 <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 许可证链接</a>。</li>
</ul>
<h2 id="🎯-核心功能">🎯 核心功能</h2>
<ul>
<li>
<p><code>ollib</code>：基础工具库，覆盖高频基础功能及 Linux 专属网络库：</p>
<ul>
<li>
<p>基础能力：文件 IO、时间处理、字符串操作、线程池、数据结构（哈希、前缀树等）；</p>
</li>
<li>
<p><strong>主从 Reactor 多线程网络库（仅限 Linux）</strong>：路径<code>ollib/include/ol_net</code>/<code>ollib/src/ol_net</code>，基于 epoll 实现，支持非阻塞 IO、边缘触发（ET），核心架构为 “1 个主 Reactor 监听连接 + N 个从 Reactor 处理 IO 事件”，支持连接管理、报文缓冲区、事件驱动回调，适用于高并发网络场景（如服务器开发）。</p>
</li>
</ul>
</li>
<li>
<p><code>oldblib</code>：多数据库交互模块，统一接口风格，支持两种主流数据库：</p>
<ul>
<li>
<p><code>oldblib/mysql</code>：MySQL 交互，基于 MySQL C API 封装，支持连接管理、SQL 执行、BLOB/TEXT 大字段操作；</p>
</li>
<li>
<p><code>oldblib/oracle</code>：Oracle 交互，基于 OCI 接口封装，支持连接管理、SQL 执行、BLOB/CLOB 大字段操作。</p>
</li>
</ul>
</li>
<li>
<p><code>ol_ftp</code>：FTP 客户端模块，基于内置<a href="https://github.com/codebrainz/ftplib">ft</a><a href="https://github.com/codebrainz/ftplib">plib</a>（路径<code>third_party/ftplib</code>），支持文件上传 / 下载、目录操作、文件列表获取。</p>
</li>
</ul>
<h2 id="📚-代码文档规范">📚 代码文档规范</h2>
<p>本项目所有头文件（<code>.h</code>）均遵循 <strong>Doxygen 注释规范</strong>，便于开发者快速理解接口功能：</p>
<ul>
<li>
<p>函数 / 类 / 结构体包含完整注释，覆盖功能描述（<code>@brief</code>）、参数说明（<code>@param</code>）、返回值（<code>@return</code>）及注意事项（<code>@note</code>）；</p>
</li>
<li>
<p>支持通过 Doxygen 自动生成 HTML/PDF 格式 API 文档；</p>
</li>
<li>
<p>主流 IDE（VS Code、CLion）可识别注释并提供智能提示，提升编码效率。</p>
</li>
</ul>
<h3 id="示例注释风格">示例注释风格</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据绝对路径逐级创建目录</span></span><br><span class="line"><span class="comment"> * @param pathorfilename 绝对路径的文件名或目录名</span></span><br><span class="line"><span class="comment"> * @param bisfilename 指定pathorfilename类型（true-文件名，false-目录名，默认true）</span></span><br><span class="line"><span class="comment"> * @return true-成功，false-失败（权限不足、路径非法、磁盘满等）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">newdir</span><span class="params">(<span class="type">const</span> std::string&amp; pathorfilename, <span class="type">bool</span> bisfilename = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="⚙️-环境依赖">⚙️ 环境依赖</h2>
<h3 id="基础依赖">基础依赖</h3>
<ul>
<li>
<p>构建工具：CMake 3.10+</p>
</li>
<li>
<p>编译器：C++17 兼容编译器（Linux：GCC 8+/Clang 7+；Windows：MSVC 2019+/MinGW 8+）</p>
</li>
<li>
<p>操作系统：</p>
<ul>
<li>
<p>网络库：<strong>仅限 Linux（内核 2.6+，需支持 epoll）</strong>；</p>
</li>
<li>
<p>其他模块：Windows 10+/Linux CentOS 7+/Ubuntu 18.04+。</p>
</li>
</ul>
</li>
</ul>
<h3 id="模块特定依赖">模块特定依赖</h3>
<table>
<thead>
<tr>
<th>模块</th>
<th>依赖项说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ollib/ol_net</code></td>
<td>Linux epoll（内核 2.6+）；无需额外安装，内核自带</td>
</tr>
<tr>
<td><code>oldblib/mysql</code></td>
<td>MySQL 客户端（5.7+），需链接<code>mysqlclient</code>库（Linux）/<code>libmysql.lib</code>（Windows）</td>
</tr>
<tr>
<td><code>oldblib/oracle</code></td>
<td>Oracle 客户端（11g+），需配置<code>ORACLE_HOME</code>环境变量</td>
</tr>
<tr>
<td><code>ol_ftp</code></td>
<td>内置 ftplib，无需额外安装</td>
</tr>
</tbody>
</table>
<h2 id="🔧-CMake-缓存变量说明">🔧 CMake 缓存变量说明</h2>
<p>所有变量可通过 <code>cmake -D&lt;变量名&gt;=&lt;值&gt;</code> 命令行配置（覆盖默认值），用于灵活控制编译行为。变量分类如下：</p>
<h3 id="1-通用配置变量">1. 通用配置变量</h3>
<table>
<thead>
<tr>
<th>变量名</th>
<th>默认值</th>
<th>可选值</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CMAKE_BUILD_TYPE</code></td>
<td>Release</td>
<td>Debug/Release/RelWithDebInfo/MinSizeRel</td>
<td>构建类型（单配置生成器如 MinGW/Linux 必需，多配置如 MSVC 无需指定）</td>
</tr>
<tr>
<td><code>ENABLE_WARNINGS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否启用编译器警告</td>
</tr>
</tbody>
</table>
<h3 id="2-ollib-库配置变量">2. <code>ollib</code> 库配置变量</h3>
<table>
<thead>
<tr>
<th>变量名</th>
<th>默认值</th>
<th>可选值</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OL_WITH_TESTS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否编译 <code>ollib</code> 的测试程序（如线程池、网络库测试）</td>
</tr>
<tr>
<td><code>OL_BUILD_STATIC_LIBS</code></td>
<td>ON</td>
<td>ON/OFF</td>
<td>是否生成 <code>ollib</code> 静态库（<code>libol.a</code>/<code>ol.lib</code>）</td>
</tr>
<tr>
<td><code>OL_BUILD_SHARED_LIBS</code></td>
<td>ON</td>
<td>ON/OFF</td>
<td>是否生成 <code>ollib</code> 动态库（<code>libol.so</code>/<code>ol.dll</code>）</td>
</tr>
</tbody>
</table>
<h3 id="3-oldblib-数据库模块配置变量">3. <code>oldblib</code> 数据库模块配置变量</h3>
<h4 id="MySQL-模块（需依赖环境变量MYSQL-HOME）">MySQL 模块（需依赖环境变量<code>MYSQL_HOME</code>）</h4>
<table>
<thead>
<tr>
<th>变量名</th>
<th>默认值</th>
<th>可选值</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OLDB_MYSQL_WITH_TESTS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否编译 MySQL 模块的测试程序</td>
</tr>
<tr>
<td><code>OLDB_MYSQL_BUILD_STATIC_LIBS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否生成 MySQL 模块静态库（<code>liboldb_mysql.a</code>/<code>oldb_mysql.lib</code>）</td>
</tr>
<tr>
<td><code>OLDB_MYSQL_BUILD_SHARED_LIBS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否生成 MySQL 模块动态库（<code>liboldb_mysql.so</code>/<code>oldb_mysql.dll</code>）</td>
</tr>
</tbody>
</table>
<h4 id="Oracle-模块（需依赖环境变量ORACLE-HOME）">Oracle 模块（需依赖环境变量<code>ORACLE_HOME</code>）</h4>
<table>
<thead>
<tr>
<th>变量名</th>
<th>默认值</th>
<th>可选值</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OLDB_ORACLE_WITH_TESTS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否编译 Oracle 模块的测试程序</td>
</tr>
<tr>
<td><code>OLDB_ORACLE_BUILD_STATIC_LIBS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否生成 Oracle 模块静态库（<code>liboldb_oracle.a</code>/<code>oldb_oracle.lib</code>）</td>
</tr>
<tr>
<td><code>OLDB_ORACLE_BUILD_SHARED_LIBS</code></td>
<td>OFF</td>
<td>ON/OFF</td>
<td>是否生成 Oracle 模块动态库（<code>liboldb_oracle.so</code>/<code>oldb_oracle.dll</code>）</td>
</tr>
</tbody>
</table>
<h3 id="变量使用示例">变量使用示例</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：Linux 下编译 Debug 版本 + 启用 ollib 测试 + 仅生成静态库</span></span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug -DOL_WITH_TESTS=ON -DOL_BUILD_SHARED_LIBS=OFF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：Windows MinGW 下编译 Release 版本 + 启用 MySQL 模块 + 生成动态库</span></span><br><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -DCMAKE_BUILD_TYPE=Release -DOLDB_MYSQL_BUILD_SHARED_LIBS=ON</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：禁用所有警告 + 同时生成 ollib 和 MySQL 静态库</span></span><br><span class="line">cmake .. -DENABLE_WARNINGS=OFF -DOL_BUILD_STATIC_LIBS=ON -DOLDB_MYSQL_BUILD_STATIC_LIBS=ON</span><br></pre></td></tr></table></figure>
<h2 id="📝-编码与格式规范">📝 编码与格式规范</h2>
<ol>
<li>
<p><strong>字符集</strong>：所有文件（<code>.h</code>/<code>.cpp</code>/<code>.cmake</code>）均采用 <strong>UTF-8（无 BOM）</strong>，避免多语言字符乱码；</p>
</li>
<li>
<p><strong>换行符</strong>：统一使用 <strong>LF（\n）</strong>，防止跨平台协作时版本控制冲突。</p>
</li>
</ol>
<h2 id="🔨-编译步骤">🔨 编译步骤</h2>
<h3 id="Linux-平台（含网络库编译）">Linux 平台（含网络库编译）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/1613661434/OL.git</span><br><span class="line"><span class="built_in">cd</span> OL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建构建目录（推荐out-of-source构建）</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成Makefile（可添加缓存变量自定义配置）</span></span><br><span class="line">cmake ..  <span class="comment"># 示例：启用测试 + 仅静态库 → cmake .. -DOL_WITH_TESTS=ON -DOL_BUILD_SHARED_LIBS=OFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 并行编译（-j后接核心数，如-j4）</span></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 输出路径</span></span><br><span class="line"><span class="comment"># - 静态库：ollib/lib/linux/x64/static/$&#123;CMAKE_BUILD_TYPE&#125;/（含网络库代码）</span></span><br><span class="line"><span class="comment"># - 动态库：ollib/lib/linux/x64/shared/$&#123;CMAKE_BUILD_TYPE&#125;/（含网络库代码）</span></span><br><span class="line"><span class="comment"># - 网络库测试程序：ollib/test/bin/linux/x64/$&#123;CMAKE_BUILD_TYPE&#125;/ol_net/（test_ol_echoserver等）</span></span><br><span class="line"><span class="comment"># - 其他测试程序：各自test/bin/linux/x64/$&#123;CMAKE_BUILD_TYPE&#125;/目录下</span></span><br></pre></td></tr></table></figure>
<h3 id="Windows-平台（不含网络库）">Windows 平台（不含网络库）</h3>
<h4 id="MSVC-编译">MSVC 编译</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/1613661434/OL.git</span><br><span class="line"><span class="built_in">cd</span> OL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建构建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成.sln文件（可添加缓存变量）</span></span><br><span class="line">cmake .. -G<span class="string">&quot;Visual Studio 17 2022&quot;</span>  <span class="comment"># 示例：Debug模式 → -DCMAKE_BUILD_TYPE=Debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. VS2022打开进行编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 输出：仅基础模块与数据库模块，无网络库</span></span><br></pre></td></tr></table></figure>
<h4 id="MinGW-编译">MinGW 编译</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/1613661434/OL.git</span><br><span class="line"><span class="built_in">cd</span> OL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建构建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成MinGW Makefile（可添加缓存变量）</span></span><br><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span>  <span class="comment"># 示例：Debug模式 → -DCMAKE_BUILD_TYPE=Debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 并行编译</span></span><br><span class="line">mingw32-make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 输出：仅基础模块与数据库模块，无网络库</span></span><br></pre></td></tr></table></figure>
<h2 id="⚠️-注意事项">⚠️ 注意事项</h2>
<ol>
<li>
<p><strong>网络库平台限制</strong>：<code>ollib/ol_net</code> 仅限 Linux，Windows 下不会编译相关代码，避免依赖冲突；</p>
</li>
<li>
<p><strong>内置依赖保护</strong>：<code>third_party/ftplib</code> 为核心依赖，请勿修改目录结构；如需更新，直接替换该目录文件并保持路径一致；</p>
</li>
<li>
<p><strong>数据库版本适配</strong>：跨平台编译时，需确保数据库客户端版本与目标平台架构匹配（如 x64 客户端对应 x64 编译目标）；</p>
</li>
<li>
<p><strong>许可证合规</strong>：使用 / 分发本项目时，需按 CC BY 4.0 要求注明来源及许可证链接。</p>
</li>
</ol>
<h3 id="终端乱码解决">终端乱码解决</h3>
<p>若 Windows PowerShell 出现中文乱码，可临时设置 UTF-8 字符集：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置输入输出编码为 UTF-8</span></span><br><span class="line"><span class="variable">$OutputEncoding</span> = [<span class="type">Console</span>]::InputEncoding = [<span class="type">Console</span>]::OutputEncoding = [<span class="type">System.Text.UTF8Encoding</span>]::UTF8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证编码（需显示 BodyName: utf-8, CodePage: 65001）</span></span><br><span class="line">[<span class="type">Console</span>]::OutputEncoding</span><br><span class="line">[<span class="type">Console</span>]::InputEncoding</span><br></pre></td></tr></table></figure>
<h2 id="📋-目录结构说明">📋 目录结构说明</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OL</span><br><span class="line">├───oldblib               <span class="comment"># 数据库交互模块</span></span><br><span class="line">│   ├───mysql             <span class="comment"># MySQL子模块（include/lib/src/test）</span></span><br><span class="line">│   └───oracle            <span class="comment"># Oracle子模块（include/lib/src/test）</span></span><br><span class="line">├───ollib                 <span class="comment"># 基础工具库（含网络库）</span></span><br><span class="line">│   ├───include</span><br><span class="line">│   │   ├───ol_base           <span class="comment"># 基础组件头文件（ol_sort_base.h等）</span></span><br><span class="line">│   │   ├───ol_net            <span class="comment"># 网络库头文件（Acceptor.h/Connection.h等）</span></span><br><span class="line">│   │   ├───third_party       <span class="comment"># 第三方库头文件（ftplib.h等）</span></span><br><span class="line">│   │   └───其他基础模块头文件</span><br><span class="line">│   ├───src</span><br><span class="line">│   │   ├───ol_base           <span class="comment"># 基础组件实现</span></span><br><span class="line">│   │   ├───ol_net            <span class="comment"># 网络库实现（Acceptor.cpp/Connection.cpp等）</span></span><br><span class="line">│   │   └───其他基础模块实现</span><br><span class="line">│   └───<span class="built_in">test</span></span><br><span class="line">│       ├───ol_net            <span class="comment"># 网络库测试（回声服务器/银行示例等）</span></span><br><span class="line">│       └───其他模块测试</span><br><span class="line">└───third_party</span><br><span class="line">│   └───ftplib            <span class="comment"># 内置FTP依赖库</span></span><br><span class="line">└───docs                  <span class="comment"># 说明文档（index.html）</span></span><br></pre></td></tr></table></figure>
<h2 id="📋-网络库详细介绍（仅限-Linux）">📋 网络库详细介绍（仅限 Linux）</h2>
<h3 id="1-架构设计">1. 架构设计</h3>
<p>采用<strong>主从 Reactor 多线程模型</strong>，核心组件分工：</p>
<ul>
<li>
<p><strong>主 Reactor</strong>：1 个线程，负责监听<code>listenfd</code>，接收新连接后分发到从 Reactor；</p>
</li>
<li>
<p><strong>从 Reactor</strong>：N 个线程（默认与 CPU 核心数一致），每个线程绑定 1 个<code>epoll</code>实例，处理已连接 fd 的 IO 事件（读 / 写）；</p>
</li>
<li>
<p><strong>事件驱动</strong>：基于<code>epoll ET</code>（边缘触发）+ 非阻塞 IO，减少不必要的事件触发，提升高并发性能。</p>
</li>
</ul>
<h3 id="2-核心组件">2. 核心组件</h3>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EventLoop</code></td>
<td>事件循环核心，管理<code>epoll</code>实例与注册的事件回调（读 / 写 / 关闭）</td>
</tr>
<tr>
<td><code>Acceptor</code></td>
<td>主 Reactor 专属，监听新连接，生成<code>SocketFd</code>后传递给从 Reactor 的<code>EventLoop</code></td>
</tr>
<tr>
<td><code>Connection</code></td>
<td>管理单个 TCP 连接，封装<code>fd</code>、输入 / 输出缓冲区（<code>Buffer</code>）及 IO 回调</td>
</tr>
<tr>
<td><code>Buffer</code></td>
<td>网络缓冲区，支持报文分隔符（四字节长度 <code>\r\n\r\n</code>）、从 fd 直接读数据</td>
</tr>
<tr>
<td><code>TcpServer</code></td>
<td>网络服务端入口，封装主从 Reactor 初始化、连接管理、回调注册（新连接 / 消息 / 关闭）</td>
</tr>
</tbody>
</table>
<h3 id="3-典型使用场景">3. 典型使用场景</h3>
<ul>
<li>
<p>高并发 TCP 服务器（如回声服务器、网关、游戏服务器）；</p>
</li>
<li>
<p>需低延迟 IO 处理的场景（依赖 epoll ET 模式减少事件开销）；</p>
</li>
<li>
<p>需统一连接管理与报文解析的网络应用（依赖<code>Buffer</code>的分隔符功能）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编 Memo</title>
    <url>/2025/12/11/%E6%B1%87%E7%BC%96%20Memo/</url>
    <content><![CDATA[<h1>汇编 Memo</h1>
<h2 id="int-21h-DOS-中断的核心功能集"><strong>int 21h</strong> DOS 中断的核心功能集</h2>
<p>在 8086 汇编的<code>int 21h</code>执行时，CPU 会自动<strong>暂停当前程序、保存 “现场” 到堆栈</strong>，压栈的顺序是固定的，从栈顶到栈底的顺序为：</p>
<ol>
<li><strong>标志寄存器（Flags）</strong>（2 字节）：先把当前程序的状态标志（比如进位、溢出等）压入栈；</li>
<li><strong>代码段寄存器（CS）</strong>（2 字节）：再把当前程序的代码段地址压入栈；</li>
<li><strong>指令指针寄存器（IP）</strong>（2 字节）：最后把当前程序的指令偏移地址压入栈。</li>
</ol>
<p>这个顺序是 8086 中断机制的固定逻辑（因为后续<code>iret</code>返回时，会按 “IP → CS → Flags” 的顺序弹出恢复现场）。</p>
<h3 id="一、控制台输入-输出功能">一、控制台输入 / 输出功能</h3>
<table>
<thead>
<tr>
<th>AH 值</th>
<th>功能描述</th>
<th>参数要求</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>01H</td>
<td>键盘输入字符（带屏幕回显）</td>
<td>无</td>
<td>AL = 输入的 ASCII 字符</td>
</tr>
<tr>
<td>02H</td>
<td>屏幕输出单个字符</td>
<td>DL = 要输出的 ASCII 字符</td>
<td>无</td>
</tr>
<tr>
<td>07H</td>
<td>键盘输入字符（无回显）</td>
<td>无</td>
<td>AL = 输入的 ASCII 字符</td>
</tr>
<tr>
<td>09H</td>
<td>屏幕输出字符串</td>
<td>DS:DX = 字符串首地址（字符串必须以<code>$</code>结尾）</td>
<td>无</td>
</tr>
<tr>
<td>0AH</td>
<td>键盘输入字符串到缓冲区</td>
<td>DS:DX = 缓冲区首地址（缓冲区第 1 字节 = 最大长度，第 2 字节 = 实际输入长度）</td>
<td>缓冲区第 3 字节开始存输入的字符串</td>
</tr>
</tbody>
</table>
<h3 id="二、文件操作功能">二、文件操作功能</h3>
<table>
<thead>
<tr>
<th>AH 值</th>
<th>功能描述</th>
<th>参数要求</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>3CH</td>
<td>创建新文件</td>
<td>DS:DX = 文件名首地址；CX = 文件属性（0 = 普通文件）</td>
<td>AX = 文件句柄（失败则 AX = 错误码）</td>
</tr>
<tr>
<td>3DH</td>
<td>打开已存在的文件</td>
<td>DS:DX = 文件名首地址；AL = 打开方式（0 = 读，1 = 写，2 = 读写）</td>
<td>AX = 文件句柄（失败则 AX = 错误码）</td>
</tr>
<tr>
<td>3FH</td>
<td>从文件读数据</td>
<td>BX = 文件句柄；CX = 要读取的字节数；DS:DX = 数据缓冲区地址</td>
<td>AX = 实际读取的字节数（0 = 文件结束）</td>
</tr>
<tr>
<td>40H</td>
<td>向文件写数据</td>
<td>BX = 文件句柄；CX = 要写入的字节数；DS:DX = 数据缓冲区地址</td>
<td>AX = 实际写入的字节数</td>
</tr>
<tr>
<td>3EH</td>
<td>关闭文件</td>
<td>BX = 文件句柄</td>
<td>无（失败则 AX = 错误码）</td>
</tr>
</tbody>
</table>
<h3 id="三、程序控制-系统功能">三、程序控制 / 系统功能</h3>
<table>
<thead>
<tr>
<th>AH 值</th>
<th>功能描述</th>
<th>参数要求</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>25H</td>
<td>设置中断向量</td>
<td>AL = 中断号；DS:DX = 中断服务程序首地址</td>
<td>无</td>
</tr>
<tr>
<td>35H</td>
<td>获取中断向量</td>
<td>AL = 中断号</td>
<td>ES:BX = 中断服务程序首地址</td>
</tr>
<tr>
<td>4CH</td>
<td>程序退出并返回 DOS</td>
<td>AL = 程序返回码</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算">逻辑运算</h2>
<ol>
<li>
<p>乘法</p>
<p><img src="/2025/12/11/%E6%B1%87%E7%BC%96%20Memo/image-20251201164254291-1764578577817-1.png" alt=""></p>
</li>
<li>
<p>除法</p>
<p><img src="/2025/12/11/%E6%B1%87%E7%BC%96%20Memo/image-20251201164344084-1764578627134-3.png" alt=""></p>
</li>
</ol>
<h2 id="串处理指令">串处理指令</h2>
<h3 id="一、核心规则">一、核心规则</h3>
<ol>
<li><strong>固定寄存器/段关联</strong>：
<ol>
<li>源串：<code>DS:SI</code>（数据段+源变址寄存器），仅 <code>LODS</code> 指令可单独使用 <code>DS:SI</code>；</li>
<li>目标串：<code>ES:DI</code>（附加段+目的变址寄存器），<code>MOVS/STOS/SCAS</code> 强制依赖 <code>ES:DI</code>，不可替换；</li>
<li>计数器：<code>CX</code>（存储串长度，所有重复前缀均依赖 <code>CX</code> 控制循环次数）；</li>
<li>方向标志：<code>DF</code>（控制 <code>SI/DI</code> 的增减方向：<code>CLD</code> 指令置 <code>DF=0</code>，正向递增；<code>STD</code> 指令置 <code>DF=1</code>，反向递减）。</li>
</ol>
</li>
<li><strong>段寄存器初始化要求</strong>：
<ol>
<li><code>ASSUME</code> 伪指令仅声明段寄存器与段的关联关系，不实际给段寄存器赋值；</li>
<li>8086 架构不允许段寄存器直接接收立即数赋值（如 <code>mov ds, data</code> 非法），必须通过通用寄存器（如 <code>AX</code>）中转；</li>
<li>示例模板：<code>mov ax, data → mov ds, ax</code>（初始化数据段）、<code>mov ax, extra → mov es, ax</code>（初始化附加段）。</li>
</ol>
</li>
<li><strong>操作单位区分</strong>：
<ol>
<li>字节操作（指令后缀 <code>B</code>）：每次处理 1 字节，<code>SI/DI</code> 按 1 递增/递减；</li>
<li>字操作（指令后缀 <code>W</code>）：每次处理 2 字节（1 个字），<code>SI/DI</code> 按 2 递增/递减。</li>
</ol>
</li>
</ol>
<h3 id="二、核心串操作指令（按用途分类）">二、核心串操作指令（按用途分类）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">功能说明</th>
<th style="text-align:left">核心操作（DF=0 正向场景）</th>
<th style="text-align:left">适用重复前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>MOVSB</code></td>
<td style="text-align:left">字节串复制</td>
<td style="text-align:left"><code>ES:[DI] = DS:[SI]</code>，随后 <code>SI+1</code>、<code>DI+1</code></td>
<td style="text-align:left"><code>REP</code></td>
</tr>
<tr>
<td style="text-align:left"><code>MOVSW</code></td>
<td style="text-align:left">字串复制</td>
<td style="text-align:left"><code>ES:[DI] = DS:[SI]</code>，随后 <code>SI+2</code>、<code>DI+2</code></td>
<td style="text-align:left"><code>REP</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CMPSB</code></td>
<td style="text-align:left">字节串比较（判断是否相等）</td>
<td style="text-align:left"><code>DS:[SI] - ES:[DI]</code>（仅影响标志位，不改变操作数），随后 <code>SI+1</code>、<code>DI+1</code></td>
<td style="text-align:left"><code>REPE/REPZ</code>、<code>REPNE/REPNZ</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CMPSW</code></td>
<td style="text-align:left">字串比较（判断是否相等）</td>
<td style="text-align:left"><code>DS:[SI] - ES:[DI]</code>（仅影响标志位），随后 <code>SI+2</code>、<code>DI+2</code></td>
<td style="text-align:left"><code>REPE/REPZ</code>、<code>REPNE/REPNZ</code></td>
</tr>
<tr>
<td style="text-align:left"><code>SCASB</code></td>
<td style="text-align:left">字节串查找（查找 <code>AL</code> 中的目标字符）</td>
<td style="text-align:left"><code>AL - ES:[DI]</code>（仅影响标志位），随后 <code>DI+1</code></td>
<td style="text-align:left"><code>REPE/REPZ</code>、<code>REPNE/REPNZ</code></td>
</tr>
<tr>
<td style="text-align:left"><code>SCASW</code></td>
<td style="text-align:left">字串查找（查找 <code>AX</code> 中的目标字）</td>
<td style="text-align:left"><code>AX - ES:[DI]</code>（仅影响标志位），随后 <code>DI+2</code></td>
<td style="text-align:left"><code>REPE/REPZ</code>、<code>REPNE/REPNZ</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LODSB</code></td>
<td style="text-align:left">加载字节串到 <code>AL</code></td>
<td style="text-align:left"><code>AL = DS:[SI]</code>，随后 <code>SI+1</code></td>
<td style="text-align:left">极少使用（重复加载无实际意义）</td>
</tr>
<tr>
<td style="text-align:left"><code>LODSW</code></td>
<td style="text-align:left">加载字串到 <code>AX</code></td>
<td style="text-align:left"><code>AX = DS:[SI]</code>，随后 <code>SI+2</code></td>
<td style="text-align:left">极少使用</td>
</tr>
<tr>
<td style="text-align:left"><code>STOSB</code></td>
<td style="text-align:left">将 <code>AL</code> 内容存储到字节串</td>
<td style="text-align:left"><code>ES:[DI] = AL</code>，随后 <code>DI+1</code></td>
<td style="text-align:left"><code>REP</code></td>
</tr>
<tr>
<td style="text-align:left"><code>STOSW</code></td>
<td style="text-align:left">将 <code>AX</code> 内容存储到字串</td>
<td style="text-align:left"><code>ES:[DI] = AX</code>，随后 <code>DI+2</code></td>
<td style="text-align:left"><code>REP</code></td>
</tr>
</tbody>
</table>
<h3 id="三、重复前缀（控制指令循环逻辑）">三、重复前缀（控制指令循环逻辑）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">重复前缀</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">循环终止条件</th>
<th style="text-align:left">典型应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REP</code></td>
<td style="text-align:left">无条件重复</td>
<td style="text-align:left">当 <code>CX = 0</code> 时终止</td>
<td style="text-align:left">串复制（<code>MOVS</code>）、串填充（<code>STOS</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>REPE/REPZ</code></td>
<td style="text-align:left">相等/结果为零则重复</td>
<td style="text-align:left">① <code>CX = 0</code>；② <code>ZF = 0</code>（比较结果不相等），满足任一即终止</td>
<td style="text-align:left">串比较（验证两串是否完全相等，找第一个不相等字符）</td>
</tr>
<tr>
<td style="text-align:left"><code>REPNE/REPNZ</code></td>
<td style="text-align:left">不相等/结果非零则重复</td>
<td style="text-align:left">① <code>CX = 0</code>；② <code>ZF = 1</code>（比较结果相等），满足任一即终止</td>
<td style="text-align:left">串查找（找第一个匹配目标字符/字的位置）</td>
</tr>
</tbody>
</table>
<h3 id="四、典型实用示例（可直接复用）">四、典型实用示例（可直接复用）</h3>
<h4 id="1-字节串复制（MOVSB-REP）">1. 字节串复制（MOVSB + REP）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.8086</span><br><span class="line">data segment</span><br><span class="line">    src_db &#x27;asd$&#x27;       ; 源字节串（4字节：a、s、d、$）</span><br><span class="line">data ends</span><br><span class="line">extra segment</span><br><span class="line">    dst_db 4 dup(?)     ; 目标字节串（预留4字节空间）</span><br><span class="line">extra ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code, ds:data, es:extra</span><br><span class="line">main:</span><br><span class="line">    ; 初始化数据段寄存器DS</span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">    ; 初始化附加段寄存器ES（目标串依赖ES:DI，必须初始化）</span><br><span class="line">    mov ax, extra</span><br><span class="line">    mov es, ax</span><br><span class="line"></span><br><span class="line">    lea si, src_db      ; SI指向源串偏移地址（DS:SI定位源串）</span><br><span class="line">    lea di, dst_db      ; DI指向目标串偏移地址（ES:DI定位目标串）</span><br><span class="line">    mov cx, 4           ; 复制长度=4字节（与源串长度一致）</span><br><span class="line">    cld                 ; 置DF=0，正向递增复制</span><br><span class="line">    rep movsb           ; 重复复制：直到CX=0</span><br><span class="line"></span><br><span class="line">    ; 程序正常退出</span><br><span class="line">    mov ah, 4Ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h4 id="2-字节串填充（STOSB-REP）">2. 字节串填充（STOSB + REP）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.8086</span><br><span class="line">extra segment</span><br><span class="line">    buf_db 10 dup(?)    ; 预留10字节缓冲区</span><br><span class="line">extra ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code, es:extra</span><br><span class="line">main:</span><br><span class="line">    mov ax, extra</span><br><span class="line">    mov es, ax           ; 初始化ES指向目标段（填充操作依赖ES:DI）</span><br><span class="line">    </span><br><span class="line">    lea di, buf_db       ; DI指向缓冲区偏移地址</span><br><span class="line">    mov al, 0            ; 填充值：0（可改为任意字节值，如&#x27;A&#x27;、0FFh等）</span><br><span class="line">    mov cx, 10           ; 填充长度=10字节</span><br><span class="line">    cld                  ; 正向填充</span><br><span class="line">    rep stosb            ; 重复填充：ES:[DI] = AL，DI递增，直到CX=0</span><br><span class="line"></span><br><span class="line">    mov ah, 4Ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h4 id="3-字节串查找（SCASB-REPNE）">3. 字节串查找（SCASB + REPNE）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.8086</span><br><span class="line">extra segment</span><br><span class="line">    str_db &#x27;hello8086$&#x27;  ; 待查找的字节串（长度=7字节）</span><br><span class="line">extra ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code, es:extra</span><br><span class="line">main:</span><br><span class="line">    mov ax, extra</span><br><span class="line">    mov es, ax           ; 初始化ES指向待查找串所在段</span><br><span class="line">    </span><br><span class="line">    lea di, str_db       ; DI指向串偏移地址</span><br><span class="line">    mov al, &#x27;8&#x27;          ; 目标查找字符（存储在AL中）</span><br><span class="line">    mov cx, 7            ; 查找范围：前7字节</span><br><span class="line">    cld                  ; 正向查找</span><br><span class="line">    repne scasb          ; 不相等则继续，找到则ZF=1，终止循环</span><br><span class="line"></span><br><span class="line">    ; 查找结果判断</span><br><span class="line">    jz  find_ok          ; ZF=1 → 找到目标字符</span><br><span class="line">    jmp find_fail        ; ZF=0 → 未找到</span><br><span class="line"></span><br><span class="line">find_ok:</span><br><span class="line">    ; 此处可添加找到后的处理逻辑（如记录位置）</span><br><span class="line">    jmp exit</span><br><span class="line">find_fail:</span><br><span class="line">    ; 此处可添加未找到的处理逻辑</span><br><span class="line">exit:</span><br><span class="line">    mov ah, 4Ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h4 id="4-字节串比较（CMPSB-REPE）">4. 字节串比较（CMPSB + REPE）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.8086</span><br><span class="line">data segment</span><br><span class="line">    str1_db &#x27;abc$&#x27;       ; 第一个比较串（长度=3字节）</span><br><span class="line">data ends</span><br><span class="line">extra segment</span><br><span class="line">    str2_db &#x27;abd$&#x27;       ; 第二个比较串（长度=3字节）</span><br><span class="line">extra ends</span><br><span class="line">code segment</span><br><span class="line">assume cs:code, ds:data, es:extra</span><br><span class="line">main:</span><br><span class="line">    ; 初始化DS和ES，分别指向两个比较串所在段</span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov ax, extra</span><br><span class="line">    mov es, ax</span><br><span class="line"></span><br><span class="line">    lea si, str1_db      ; SI指向str1偏移（DS:SI）</span><br><span class="line">    lea di, str2_db      ; DI指向str2偏移（ES:DI）</span><br><span class="line">    mov cx, 3            ; 比较长度=3字节</span><br><span class="line">    cld                  ; 正向比较</span><br><span class="line">    repe cmpsb           ; 相等则继续，直到CX=0或找到不相等字符</span><br><span class="line"></span><br><span class="line">    ; 比较结果判断</span><br><span class="line">    jz  str_equal        ; ZF=1且CX=0 → 两串完全相等</span><br><span class="line">    jmp str_not_equal    ; 否则 → 不相等</span><br><span class="line"></span><br><span class="line">str_equal:</span><br><span class="line">    ; 两串相等的处理逻辑</span><br><span class="line">    jmp exit</span><br><span class="line">str_not_equal:</span><br><span class="line">    ; 两串不相等的处理逻辑</span><br><span class="line">exit:</span><br><span class="line">    mov ah, 4Ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h3 id="五、易错点速记">五、易错点速记</h3>
<ol>
<li>遗漏 <code>ES</code> 初始化：<code>MOVS/STOS/SCAS</code> 指令强制依赖 <code>ES:DI</code>，未初始化<code>ES</code> 会导致访问非法内存，程序崩溃；</li>
<li>方向标志未显式设置：默认 <code>DF</code> 状态不确定，务必用 <code>CLD</code>（正向）或 <code>STD</code>（反向）显式指定，避免 SI/DI 增减方向错误；</li>
<li>串长度与 <code>CX</code> 不匹配：<code>CX</code> 值大于串实际长度会导致内存越界，小于则复制/比较/查找不完整；</li>
<li>混淆重复前缀适用场景：<code>REP</code> 不可用于 <code>CMPS/SCAS</code>，<code>REPE/REPNE</code> 不可用于 <code>MOVS/STOS</code>，否则逻辑错误；</li>
<li>DOS 中断 <code>09h</code> 地址限制：该中断输出字符串要求地址为 <code>DS:DX</code>，若需输出 <code>ES</code>段的串，需临时将 <code>DS</code> 切换为 <code>ES</code> 对应的段基址。</li>
</ol>
<h2 id="ASCII码表">ASCII码表</h2>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符/缩写</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>00</td>
<td>NUL (NULL)</td>
<td>空字符</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>01</td>
<td>SOH (Start Of Headling)</td>
<td>标题开始</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>02</td>
<td>STX (Start Of Text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>03</td>
<td>ETX (End Of Text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>00000100</td>
<td>4</td>
<td>04</td>
<td>EOT (End Of Transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>00000101</td>
<td>5</td>
<td>05</td>
<td>ENQ (Enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>00000110</td>
<td>6</td>
<td>06</td>
<td>ACK (Acknowledge)</td>
<td>回应/响应/收到通知</td>
</tr>
<tr>
<td>00000111</td>
<td>7</td>
<td>07</td>
<td>BEL (Bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>00001000</td>
<td>8</td>
<td>08</td>
<td>BS (Backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>00001001</td>
<td>9</td>
<td>09</td>
<td>HT (Horizontal Tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>00001010</td>
<td>10</td>
<td>0A</td>
<td>LF/NL (Line Feed/New Line)</td>
<td>换行键</td>
</tr>
<tr>
<td>00001011</td>
<td>11</td>
<td>0B</td>
<td>VT (Vertical Tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>00001100</td>
<td>12</td>
<td>0C</td>
<td>FF/NP (Form Feed/New Page)</td>
<td>换页键</td>
</tr>
<tr>
<td>00001101</td>
<td>13</td>
<td>0D</td>
<td>CR (Carriage Return)</td>
<td>回车键</td>
</tr>
<tr>
<td>00001110</td>
<td>14</td>
<td>0E</td>
<td>SO (Shift Out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>0F</td>
<td>SI (Shift In)</td>
<td>启用切换</td>
</tr>
<tr>
<td>00010000</td>
<td>16</td>
<td>10</td>
<td>DLE (Data Link Escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>00010001</td>
<td>17</td>
<td>11</td>
<td>DC1/XON (Device Control 1/Transmission On)</td>
<td>设备控制1/传输开始</td>
</tr>
<tr>
<td>00010010</td>
<td>18</td>
<td>12</td>
<td>DC2 (Device Control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>00010011</td>
<td>19</td>
<td>13</td>
<td>DC3/XOFF (Device Control 3/Transmission Off)</td>
<td>设备控制3/传输中断</td>
</tr>
<tr>
<td>00010100</td>
<td>20</td>
<td>14</td>
<td>DC4 (Device Control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>00010101</td>
<td>21</td>
<td>15</td>
<td>NAK (Negative Acknowledge)</td>
<td>无响应/非正常响应/拒绝接收</td>
</tr>
<tr>
<td>00010110</td>
<td>22</td>
<td>16</td>
<td>SYN (Synchronous Idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>00010111</td>
<td>23</td>
<td>17</td>
<td>ETB (End of Transmission Block)</td>
<td>传输块结束/块传输终止</td>
</tr>
<tr>
<td>00011000</td>
<td>24</td>
<td>18</td>
<td>CAN (Cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>00011001</td>
<td>25</td>
<td>19</td>
<td>EM (End of Medium)</td>
<td>已到介质末端/介质存储已满/介质中断</td>
</tr>
<tr>
<td>00011010</td>
<td>26</td>
<td>1A</td>
<td>SUB (Substitute)</td>
<td>替补/替换</td>
</tr>
<tr>
<td>00011011</td>
<td>27</td>
<td>1B</td>
<td>ESC (Escape)</td>
<td>逃离/取消</td>
</tr>
<tr>
<td>00011100</td>
<td>28</td>
<td>1C</td>
<td>FS (File Separator)</td>
<td>文件分割符</td>
</tr>
<tr>
<td>00011101</td>
<td>29</td>
<td>1D</td>
<td>GS (Group Separator)</td>
<td>组分隔符/分组符</td>
</tr>
<tr>
<td>00011110</td>
<td>30</td>
<td>1E</td>
<td>RS (Record Separator)</td>
<td>记录分离符</td>
</tr>
<tr>
<td>00011111</td>
<td>31</td>
<td>1F</td>
<td>US (Unit Separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>00100000</td>
<td>32</td>
<td>20</td>
<td>(Space)</td>
<td>空格</td>
</tr>
<tr>
<td>00100001</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td></td>
</tr>
<tr>
<td>00100010</td>
<td>34</td>
<td>22</td>
<td>&quot;</td>
<td></td>
</tr>
<tr>
<td>00100011</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td></td>
</tr>
<tr>
<td>00100100</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td></td>
</tr>
<tr>
<td>00100101</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td></td>
</tr>
<tr>
<td>00100110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td></td>
</tr>
<tr>
<td>00100111</td>
<td>39</td>
<td>27</td>
<td>’</td>
<td></td>
</tr>
<tr>
<td>00101000</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td></td>
</tr>
<tr>
<td>00101001</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td></td>
</tr>
<tr>
<td>00101010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>00101011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>00101100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td></td>
</tr>
<tr>
<td>00101101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>00101110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td></td>
</tr>
<tr>
<td>00101111</td>
<td>47</td>
<td>2F</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>00110000</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>00110001</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>00110010</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>00110011</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>00110100</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>00110101</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>00110110</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>00110111</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>00111000</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>00111001</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>00111010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>00111011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td></td>
</tr>
<tr>
<td>00111100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>00111101</td>
<td>61</td>
<td>3D</td>
<td>=</td>
<td></td>
</tr>
<tr>
<td>00111110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>00111111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>01000000</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td></td>
</tr>
<tr>
<td>01000001</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td></td>
</tr>
<tr>
<td>01000010</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>01000011</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>01000100</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>01000101</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td></td>
</tr>
<tr>
<td>01000110</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>01000111</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>01001000</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td></td>
</tr>
<tr>
<td>01001001</td>
<td>73</td>
<td>49</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>01001010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>01001011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td></td>
</tr>
<tr>
<td>01001100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td></td>
</tr>
<tr>
<td>01001101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td></td>
</tr>
<tr>
<td>01001110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>01001111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>01010000</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td></td>
</tr>
<tr>
<td>01010001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td></td>
</tr>
<tr>
<td>01010010</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td></td>
</tr>
<tr>
<td>01010011</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>01010100</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>01010101</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td></td>
</tr>
<tr>
<td>01010110</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>01010111</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td>01011000</td>
<td>88</td>
<td>58</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>01011001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>01011010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>01011011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td></td>
</tr>
<tr>
<td>01011100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>01011101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td></td>
</tr>
<tr>
<td>01011110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td></td>
</tr>
<tr>
<td>01011111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td></td>
</tr>
<tr>
<td>01100000</td>
<td>96</td>
<td>60</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>01100001</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td></td>
</tr>
<tr>
<td>01100010</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>01100011</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td></td>
</tr>
<tr>
<td>01100100</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td></td>
</tr>
<tr>
<td>01100101</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td></td>
</tr>
<tr>
<td>01100110</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td></td>
</tr>
<tr>
<td>01100111</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td></td>
</tr>
<tr>
<td>01101000</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td></td>
</tr>
<tr>
<td>01101001</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td></td>
</tr>
<tr>
<td>01101010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td></td>
</tr>
<tr>
<td>01101011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td></td>
</tr>
<tr>
<td>01101100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td></td>
</tr>
<tr>
<td>01101101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td></td>
</tr>
<tr>
<td>01101110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td>01101111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td></td>
</tr>
<tr>
<td>01110000</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td></td>
</tr>
<tr>
<td>01110001</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td></td>
</tr>
<tr>
<td>01110010</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td></td>
</tr>
<tr>
<td>01110011</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td></td>
</tr>
<tr>
<td>01110100</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td></td>
</tr>
<tr>
<td>01110101</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td></td>
</tr>
<tr>
<td>01110110</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td></td>
</tr>
<tr>
<td>01110111</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td></td>
</tr>
<tr>
<td>01111000</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>01111001</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>01111010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td></td>
</tr>
<tr>
<td>01111011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td></td>
</tr>
<tr>
<td>01111100</td>
<td>124</td>
<td>7C</td>
<td></td>
<td></td>
</tr>
<tr>
<td>01111101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td></td>
</tr>
<tr>
<td>01111110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>01111111</td>
<td>127</td>
<td>7F</td>
<td>DEL (Delete)</td>
<td>删除</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
